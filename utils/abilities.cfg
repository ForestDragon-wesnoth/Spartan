#textdomain wesnoth-Hoplite

#define HOPLITE_LAVA_EXPLOSION_KILL UNITVAR ATTACKER_UNIT_VAR
    [object]
        silent=yes
        duration=forever
        [filter]
            id=${UNITVAR}.id
        [/filter]
        [effect]
            apply_to=new_animation
            [extra_anim]
                flag=explode
                [missile_frame]
                    halo="projectiles/fireball-impact-[1~16].png:60"
                    offset=0.0
                    auto_vflip=no
                [/missile_frame]
                [frame]
                    alpha=1~0:200,0
                    sound=fire.wav
                [/frame]
            [/extra_anim]
        [/effect]
    [/object]

    [animate_unit]
        flag=explode
        [filter]
            id=${UNITVAR}.id
        [/filter]
    [/animate_unit]
    [kill]
        id=${UNITVAR}.id
        animate=no
        fire_event=yes
        [secondary_unit]
            id=${ATTACKER_UNIT_VAR}.id
        [/secondary_unit]
    [/kill]
    #note: if I decide to give full knockback to allies, maybe add an exception for allies here
    {VARIABLE_OP shieldbash_progress${ATTACKER_UNIT_VAR}.side add 1}
    {IF_VAR shieldbash_progress${ATTACKER_UNIT_VAR}.side equals 10 (
        [then]
            {ACHIEVEMENT_MESSAGE_LONE shieldbash ${ATTACKER_UNIT_VAR}.side}
        [/then]
    )}
    #achievement for lava/chasm boss kills:
    [if]
        {VARIABLE_CONDITIONAL {UNITVAR}.abilities.hoplite_boss.is_boss equals yes}#[have_unit] doesn't work on dead units, so using a variable check instead
        [then]
            {ACHIEVEMENT_MESSAGE_LONE this_is_sparta ${ATTACKER_UNIT_VAR}.side}
        [/then]
    [/if]

    #    [fire_event]
    #       id=hoplite_death_event
    #    [/fire_event]
#enddef

#define HOPLITE_KNOCKBACK_CODE UNITVAR ATTACKER_UNIT_VAR DIRECTION
    {VARIABLE tmp_origloc_x ${UNITVAR}.x}
    {VARIABLE tmp_origloc_y ${UNITVAR}.y}
    [store_locations]
        [not]
            [filter]
            [/filter]
        [/not]

        [filter_adjacent_location]
            x,y=$tmp_origloc_x,$tmp_origloc_y
            adjacent={DIRECTION}
        [/filter_adjacent_location]
        include_borders=no

        variable=knockback_target_hex
    [/store_locations]

    {IF_VAR knockback_target_hex.length greater_than 0 (
        [else]
            [store_locations]
                [not]
                    [filter]
                    [/filter]
                [/not]

                [filter_adjacent_location]
                    x,y=$tmp_origloc_x,$tmp_origloc_y
                    adjacent={DIRECTION}
                [/filter_adjacent_location]
                include_borders=yes

                variable=knockback_target_hex
            [/store_locations]
            {VARIABLE tmp_knockback_border yes}
        [/else]
    )}

    #    [if]
    #        [variable]
    #            name=tmp_knockback_border
    #            equals=yes
    #        [/variable]
    #        [then]
    #            [chat]
    #                message="pushing enemy into border. terrain: $knockback_target_hex.terrain|"
    #            [/chat]
    #        [/then]
    #    [/if]

    [if]
        [variable]
            name=knockback_target_hex.length
            greater_than=0
        [/variable]
        [and]
            [have_location]
                x,y=$knockback_target_hex.x,$knockback_target_hex.y
                #                terrain=!,Qx**
                include_borders=yes
            [/have_location]
        [/and]

        [then]
            {IF_VAR tmp_knockback_border not_equals yes (
                [then]
                    [move_unit]
                        id=${UNITVAR}.id
                        to_x,to_y=$knockback_target_hex.x,$knockback_target_hex.y
                        check_passability=no
                    [/move_unit]
                [/then]
            )}

            #sets tmp_return_movecost and tmp_return_passable variables, the latter of which is used for the code:
            {SPARTAN_CHECK_MOVECOST ${UNITVAR}.id $knockback_target_hex.x $knockback_target_hex.y}

            [if]
                [have_location]
                    x,y=$knockback_target_hex.x,$knockback_target_hex.y
                    terrain={SPARTAN_WALL_TERRAIN}
                    include_borders=yes
                [/have_location]
                #                [have_unit]
                #                    id=${UNITVAR}.id
                #                    [filter_location]
                #                        terrain={SPARTAN_WALL_TERRAIN}
                #                    [/filter_location]
                #                [/have_unit]
                #                [and]
                #                    [variable]
                #                        name=damagebashedthisturn
                #                        not_equals=yes
                #                    [/variable]
                #                [/and]
                [then]
                    {VARIABLE tmp_bashdamage 5}
                    {VARIABLE_OP tmp_bashdamage multiply $tmp_times_left}
                    {QUAKE "rumble.ogg"}
                    {IF_VAR tmp_bashdamage greater_than_equal_to ${UNITVAR}.hitpoints (
                        [then]
                            [kill]
                                id=${UNITVAR}.id
                                animate=yes
                                fire_event=yes
                                [secondary_unit]
                                    id=${ATTACKER_UNIT_VAR}.id
                                [/secondary_unit]
                            [/kill]
                            #                    [fire_event]
                            #                       id=hoplite_death_event
                            #                    [/fire_event]
                        [/then]
                        [else]
                            [move_unit]
                                id=${UNITVAR}.id
                                to_x,to_y=$tmp_origloc_x,$tmp_origloc_y
                                check_passability=yes
                            [/move_unit]
                            [spartan_harm_unit]
                                [filter]
                                    id=${UNITVAR}.id
                                [/filter]
                                [filter_second]
                                    id=${ATTACKER_UNIT_VAR}.id
                                [/filter_second]
                                amount=$tmp_bashdamage
                                damage_type=impact
                                fire_event=no
                                kill=no
                                animate=defender
                                delay=0
                                experience=no
                            [/spartan_harm_unit]
                            {VARIABLE damagebashedthisturn yes}
                        [/else]
                    )}
                [/then]
                [elseif]
                    [have_location]
                        x,y=$knockback_target_hex.x,$knockback_target_hex.y
                        terrain=Qlf^*
                        include_borders=yes
                    [/have_location]
                    [and]
                        [have_unit]
                            id=${UNITVAR}.id
                            #                        [not]
                            #                            ability=hoplite_flying
                            #                        [/not]
                            [not]
                                ability=hoplite_boss
                            [/not]
                        [/have_unit]
                    [/and]
                    [and]
                        {VARIABLE_CONDITIONAL tmp_current_knockback_lesser not_equals yes}#lesser knockback prevents instakills
                    [/and]
                    [and]
                        {VARIABLE_CONDITIONAL tmp_return_passable equals no}
                    [/and]
                    [then]
                        {HOPLITE_LAVA_EXPLOSION_KILL {UNITVAR} {ATTACKER_UNIT_VAR}}
                    [/then]
                [/elseif]
                #if a boss is pushed into lava (or the attacker has lesser knockback), it just takes some damage instead of being instakilled
                [elseif]
                    [have_location]
                        x,y=$knockback_target_hex.x,$knockback_target_hex.y
                        terrain=Qlf^*
                        include_borders=yes
                    [/have_location]
                    [and]
                        [have_unit]
                            id=${UNITVAR}.id
                            ability=hoplite_boss
                            #                        [not]
                            #                            ability=hoplite_flying
                            #                        [/not]
                        [/have_unit]
                        [or]
                            {VARIABLE_CONDITIONAL tmp_current_knockback_lesser equals yes}
                            #                        [and]
                            #                            [have_unit]
                            #                                id=${UNITVAR}.id
                            #                                [not]
                            #                                    ability=hoplite_flying
                            #                                [/not]
                            #                            [/have_unit]
                            #                        [/and]
                        [/or]
                    [/and]
                    [and]
                        {VARIABLE_CONDITIONAL tmp_return_passable equals no}
                    [/and]
                    [then]
                        {VARIABLE tmp_bashdamage 10}
                        {VARIABLE_OP tmp_bashdamage multiply $tmp_times_left}
                        {IF_VAR tmp_bashdamage greater_than_equal_to ${UNITVAR}.hitpoints (
                            [then]
                                {HOPLITE_LAVA_EXPLOSION_KILL {UNITVAR} {ATTACKER_UNIT_VAR}}
                            [/then]
                            [else]
                                [sound]
                                    name=fire.wav
                                [/sound]
                                [move_unit]
                                    id=${UNITVAR}.id
                                    to_x,to_y=$tmp_origloc_x,$tmp_origloc_y
                                    check_passability=yes
                                [/move_unit]
                                [spartan_harm_unit]
                                    [filter]
                                        id=${UNITVAR}.id
                                    [/filter]
                                    [filter_second]
                                        id=${ATTACKER_UNIT_VAR}.id
                                    [/filter_second]
                                    amount=$tmp_bashdamage
                                    damage_type=fire
                                    fire_event=no
                                    kill=no
                                    animate=defender
                                    delay=0
                                    experience=no
                                [/spartan_harm_unit]
                                {VARIABLE damagebashedthisturn yes}
                            [/else]
                        )}
                    [/then]
                [/elseif]
                [elseif]
                    [have_location]
                        x,y=$knockback_target_hex.x,$knockback_target_hex.y
                        terrain=Qx*^*#bashing into a chasm
                        include_borders=yes
                    [/have_location]
                    [and]
                        [have_unit]
                            id=${UNITVAR}.id
                            #bosses are still immune as usual, but flying enemies are checked by movecost
                            #                        [not]
                            #                            ability=hoplite_flying
                            #                        [/not]
                            [not]
                                ability=hoplite_boss
                            [/not]
                        [/have_unit]
                    [/and]
                    [and]
                        {VARIABLE_CONDITIONAL tmp_current_knockback_lesser not_equals yes}#lesser knockback prevents instakills
                    [/and]
                    [and]
                        {VARIABLE_CONDITIONAL tmp_return_passable equals no}
                    [/and]
                    [then]
                        [sound]
                            name=falling_enemy.ogg
                        [/sound]
                        [kill]
                            x,y=$knockback_target_hex.x,$knockback_target_hex.y
                            side=$hoplite_enemyside
                            animate=no
                            fire_event=yes
                            [secondary_unit]
                                id=${ATTACKER_UNIT_VAR}.id
                            [/secondary_unit]
                        [/kill]
                        #note: if I decide to give full knockback to allies, maybe add an exception for allies here
                        {VARIABLE_OP shieldbash_progress${ATTACKER_UNIT_VAR}.side add 1}
                        {IF_VAR shieldbash_progress${ATTACKER_UNIT_VAR}.side equals 10 (
                            [then]
                                {ACHIEVEMENT_MESSAGE_LONE shieldbash ${ATTACKER_UNIT_VAR}.side}
                            [/then]
                        )}
                        #                    [fire_event]
                        #                       id=hoplite_death_event
                        #                    [/fire_event]
                    [/then]
                [/elseif]
                #if a boss is pushed into a chasm (or the attacker has lesser knockback), it just takes some damage instead of being instakilled
                [elseif]
                    [have_location]
                        x,y=$knockback_target_hex.x,$knockback_target_hex.y
                        terrain=Qx*^*#bashing into a chasm
                        include_borders=yes
                    [/have_location]
                    [and]
                        [have_unit]
                            id=${UNITVAR}.id
                            ability=hoplite_boss
                            #                        [not]
                            #                            ability=hoplite_flying
                            #                        [/not]
                        [/have_unit]
                        [or]
                            {VARIABLE_CONDITIONAL tmp_current_knockback_lesser equals yes}
                            #                        [and]
                            #                            [have_unit]
                            #                                id=${UNITVAR}.id
                            #                                [not]
                            #                                    ability=hoplite_flying
                            #                                [/not]
                            #                            [/have_unit]
                            #                        [/and]
                        [/or]
                    [/and]
                    [and]
                        {VARIABLE_CONDITIONAL tmp_return_passable equals no}
                    [/and]
                    [then]
                        {VARIABLE tmp_bashdamage 10}
                        {VARIABLE_OP tmp_bashdamage multiply $tmp_times_left}
                        {QUAKE "rumble.ogg"}
                        {IF_VAR tmp_bashdamage greater_than_equal_to ${UNITVAR}.hitpoints (
                            [then]
                                [kill]
                                    id=${UNITVAR}.id
                                    animate=yes
                                    fire_event=yes
                                    [secondary_unit]
                                        id=${ATTACKER_UNIT_VAR}.id
                                    [/secondary_unit]
                                [/kill]
                                #                    [fire_event]
                                #                       id=hoplite_death_event
                                #                    [/fire_event]
                                #achievement for lava/chasm boss kills:
                                [if]
                                    {VARIABLE_CONDITIONAL {UNITVAR}.abilities.hoplite_boss.is_boss equals yes}#[have_unit] doesn't work on dead units, so using a variable check instead
                                    [then]
                                        {ACHIEVEMENT_MESSAGE_LONE this_is_sparta ${ATTACKER_UNIT_VAR}.side}
                                    [/then]
                                [/if]
                                #note: if I decide to give full knockback to allies, maybe add an exception for allies here
                                {VARIABLE_OP shieldbash_progress${ATTACKER_UNIT_VAR}.side add 1}
                                {IF_VAR shieldbash_progress${ATTACKER_UNIT_VAR}.side equals 10 (
                                    [then]
                                        {ACHIEVEMENT_MESSAGE_LONE shieldbash ${ATTACKER_UNIT_VAR}.side}
                                    [/then]
                                )}
                            [/then]
                            [else]
                                [move_unit]
                                    id=${UNITVAR}.id
                                    to_x,to_y=$tmp_origloc_x,$tmp_origloc_y
                                    check_passability=yes
                                [/move_unit]
                                [spartan_harm_unit]
                                    [filter]
                                        id=${UNITVAR}.id
                                    [/filter]
                                    [filter_second]
                                        id=${ATTACKER_UNIT_VAR}.id
                                    [/filter_second]
                                    amount=$tmp_bashdamage
                                    damage_type=impact
                                    fire_event=no
                                    kill=no
                                    animate=defender
                                    delay=0
                                    experience=no
                                [/spartan_harm_unit]
                                {VARIABLE damagebashedthisturn yes}
                            [/else]
                        )}
                    [/then]
                [/elseif]
                [elseif]
                    [have_location]
                        x,y=$knockback_target_hex.x,$knockback_target_hex.y
                        terrain=W*^*,S*^*
                        [not]
                            terrain=Wwf^*#ford is unaffected
                        [/not]
                        include_borders=yes
                    [/have_location]
                    [and]
                        [have_unit]
                            id=${UNITVAR}.id
                            #                        [not]
                            #                            ability=hoplite_swimmer
                            #                            [or]
                            #                                ability=hoplite_flying
                            #                            [/or]
                            #                        [/not]
                        [/have_unit]
                    [/and]
                    [and]
                        {VARIABLE_CONDITIONAL tmp_return_passable equals no}
                    [/and]
                    [then]
                        {VARIABLE tmp_bashdamage 5}
                        {VARIABLE_OP tmp_bashdamage multiply $tmp_times_left}
                        [sound]
                            name=water-blast.wav
                        [/sound]
                        {IF_VAR tmp_bashdamage greater_than_equal_to ${UNITVAR}.hitpoints (
                            [then]
                                [kill]
                                    x,y=$knockback_target_hex.x,$knockback_target_hex.y
                                    side=$hoplite_enemyside
                                    animate=yes
                                    fire_event=yes
                                [/kill]
                                #                    [fire_event]
                                #                       id=hoplite_death_event
                                #                    [/fire_event]
                            [/then]
                            [else]
                                [move_unit]
                                    id=${UNITVAR}.id
                                    to_x,to_y=$tmp_origloc_x,$tmp_origloc_y
                                    check_passability=yes
                                [/move_unit]
                                [spartan_harm_unit]
                                    [filter]
                                        id=${UNITVAR}.id
                                    [/filter]
                                    [filter_second]
                                        id=${ATTACKER_UNIT_VAR}.id
                                    [/filter_second]
                                    amount=$tmp_bashdamage
                                    damage_type=cold
                                    fire_event=no
                                    kill=no
                                    animate=defender
                                    delay=0
                                    experience=no
                                [/spartan_harm_unit]
                                {VARIABLE damagebashedthisturn yes}
                            [/else]
                        )}
                    [/then]
                [/elseif]
            [/if]

            [if]
                [have_unit]
                    id=${UNITVAR}.id
                [/have_unit]
                [then]
                    [store_unit]
                        [filter]
                            id=${UNITVAR}.id
                        [/filter]
                        kill=no
                        variable=knockbacked
                    [/store_unit]
                    {IF_VAR tmp_current_knockback_lesser not_equals yes (
                        [then]
                            {VARIABLE knockbacked.status.slowed yes}
                        [/then]
                    )}
                    [unstore_unit]
                        variable=knockbacked
                        text= _ "Knockback!"
                        {COLOR_HARM}
                        find_vacant=no
                    [/unstore_unit]

                    {CLEAR_VARIABLE knockbacked}
                [/then]
            [/if]
        [/then]
    [/if]

    [if]
        #        {VARIABLE_CONDITIONAL damagebashedthisturn not_equals yes}
        [have_unit]
            id=${UNITVAR}.id
            x,y=$knockback_target_hex.x,$knockback_target_hex.y
        [/have_unit]
        [then]
            {VARIABLE tmp_knockback_succeeded yes}
            #            [chat]
            #                message=$knockback_target_hex.x|,$knockback_target_hex.y|
            #            [/chat]
        [/then]
        [else]
            {VARIABLE tmp_knockback_succeeded no}
        [/else]
    [/if]

    {CLEAR_VARIABLE knockback_direction,knockback_target_hex,damagebashedthisturn,tmp_knockback_border}
    {CLEAR_VARIABLE tmp_return_movecost,tmp_return_passable}
#enddef

#define HOPLITE_KNOCKBACK_CHAINBASH UNITVAR ATTACKER_UNIT_VAR DIRECTION
    [if]
        [have_unit]
            [filter_location]
                [filter_adjacent_location]
                    [filter]
                        x,y=${UNITVAR}.x,${UNITVAR}.y
                    [/filter]
                    adjacent={DIRECTION}
                [/filter_adjacent_location]
            [/filter_location]
        [/have_unit]
        #no longer needed, since 1. [have_unit] breaks the "chainbash with a killed enemy" mechanic, and 2. knockback_immune filter is now obsolete
        #(since knockback immune is now just resist 999)
        #    [and]
        #    [have_unit]
        #        id=${UNITVAR}.id
        #        [not]
        #            ability=knockback_immune
        #        [/not]
        #    [/have_unit]
        #    [/and]
        [then]
            [store_unit]
                [filter]
                    [filter_location]
                        [filter_adjacent_location]
                            [filter]
                                x,y=${UNITVAR}.x,${UNITVAR}.y
                            [/filter]
                            adjacent={DIRECTION}
                        [/filter_adjacent_location]
                    [/filter_location]
                    #filter is not needed at the moment
                    #                [not]
                    #                    ability=knockback_immune
                    #                [/not]
                [/filter]
                variable=tmp_chainbashed_unit
                kill=no
            [/store_unit]
            #saving these variables so they don't affect the knockback of the previous unit
            {VARIABLE tmp_times_left_orig $tmp_times_left}
            {VARIABLE tmp_knockback_succeeded_orig $tmp_knockback_succeeded}
            {VARIABLE_OP tmp_times_left sub 1}#to reduce the power of collision damage
            {VARIABLE_OP tmp_times_left sub $tmp_chainbashed_unit.abilities.knockback_resistance.value}
            #        {IF_VAR tmp_times_left greater_than_equal_to $tmp_chainbashed_unit.abilities.knockback_resistance.value (
            #        [then]
            #[chat]
            #    message=$tmp_times_left
            #[/chat]

            {IF_VAR tmp_times_left greater_than 0 (
                [then]
                    {HOPLITE_KNOCKBACK_CODE tmp_chainbashed_unit {ATTACKER_UNIT_VAR} {DIRECTION}}
                [/then]
                [else]
                    {IF_VAR tmp_current_knockback_lesser not_equals yes (
                    [and]
                        #reason for this: if a unit is chainbashed into a knockback-resistant-enough unit, then tmp_times_left will be negative, otherwise it will be 0, in which case slow the unit that was chainbased into as usual
                        {VARIABLE_CONDITIONAL tmp_times_left greater_than -1}
                    [/and]
                        [then]
                            [modify_unit]
                                [filter]
                                    id=$tmp_chainbashed_unit.id
                                [/filter]
                                [status]
                                    slowed=yes
                                [/status]
                            [/modify_unit]
                        [/then]
                    )}
                [/else]
            )}
            #        [/then]
            #        )}
            {VARIABLE tmp_times_left $tmp_times_left_orig}
            {VARIABLE tmp_knockback_succeeded $tmp_knockback_succeeded_orig}
        [/then]
    [/if]
#enddef

#define HOPLITE_KNOCKBACK_CODE_REPEATED TIMES UNITVAR ATTACKER_UNIT_VAR DIRECTION
    {VARIABLE tmp_knockback_succeeded yes}
    {VARIABLE tmp_times {TIMES}}
    {VARIABLE_OP tmp_times sub ${UNITVAR}.abilities.knockback_resistance.value}
    {VARIABLE tmp_times_left $tmp_times}

    {IF_VAR tmp_times_left greater_than_equal_to ${UNITVAR}.abilities.knockback_resistance.value (
        [then]
            {IF_VAR tmp_current_knockback_lesser not_equals yes (
                [then]
                    [modify_unit]
                        [filter]
                            id=${UNITVAR}.id
                        [/filter]
                        [status]
                            slowed=yes
                        [/status]
                    [/modify_unit]
                [/then]
            )}
        [/then]
    )}

    [while]
        [variable]
            name=tmp_times_left
            greater_than=0
        [/variable]

        [do]
            [store_unit]
                [filter]
                    id=${UNITVAR}.id
                [/filter]
                variable=tmp_knockback_target#storing the unit again to refresh the coordinates
                kill=no
            [/store_unit]

            {IF_VAR tmp_knockback_target.hitpoints less_than 1 (
                [then]
                    #unit temporarily is given 1 hp to ensure have_unit checks work properly
                    [modify_unit]
                        [filter]
                            id=${UNITVAR}.id
                        [/filter]
                        hitpoints=1
                        {VARIABLE knockback_kill_at_end yes}
                    [/modify_unit]
                [/then]
            )}

            {HOPLITE_KNOCKBACK_CHAINBASH tmp_knockback_target {ATTACKER_UNIT_VAR} {DIRECTION}}
            {IF_VAR tmp_knockback_succeeded equals yes (
                #removed this check, so that it's possible to push a killed unit into another unit. the unit is manually killed later
                #            [and]
                #                {VARIABLE_CONDITIONAL tmp_knockback_target.hitpoints greater_than 0}
                #            [/and]
                [then]
                    {HOPLITE_KNOCKBACK_CODE tmp_knockback_target {ATTACKER_UNIT_VAR} {DIRECTION}}
                [/then]
            )}

            {VARIABLE_OP tmp_times_left sub 1}
            {CLEAR_VARIABLE tmp_knockback_target}
        [/do]
    [/while]

    [store_unit]
        [filter]
            id=${UNITVAR}.id
        [/filter]
        variable=tmp_knockback_target#storing the unit again to refresh the coordinates
        kill=no
    [/store_unit]

    [if]
        {VARIABLE_CONDITIONAL tmp_knockback_target.variables.knockback_kill_at_end equals yes}
        [then]
            #delete the knockback_kill_at_end variable, otherwise it can leads up bugs if the target unit gets revived after a knockback kill (like with companions fleeing)
            [modify_unit]
                [filter]
                    id=${UNITVAR}.id
                [/filter]
                {CLEAR_VARIABLE knockback_kill_at_end}
            [/modify_unit]
            [kill]
                id=${UNITVAR}.id
                animate=yes
                fire_event=yes
                [secondary_unit]
                    id=${ATTACKER_UNIT_VAR}.id
                [/secondary_unit]
            [/kill]
        [/then]
    [/if]
    {CLEAR_VARIABLE tmp_knockback_target}

    {CLEAR_VARIABLE tmp_knockback_succeeded}
    {CLEAR_VARIABLE tmp_times}
    {CLEAR_VARIABLE tmp_times_left}
#enddef

#sweeping/spinnish bash are now actual abilities used for filters instead of purely decorative, so they can be now given to allies

#define WEAPON_SPECIAL_SPARTAN_SWEEPINGBASH
    [dummy]
        id=spartan_sweepingbash
        name=_"sweeping bash"
        description=_"This attack can knock back several enemies at once (knocks back enemies that are adjacent to both you and the target)"
    [/dummy]
#enddef

#define WEAPON_SPECIAL_SPARTAN_SPINNINGBASH
    [dummy]
        id=spartan_spinningbash
        name=_"spinning bash"
        description=_"This attack knows back all enemies adjacent to the unit."
    [/dummy]
#enddef

#for upgrades/[object]s
#define SPARTAN_KNOCKBACKSPECIAL DISTANCE
    [spartan_knockback]
        id=knockback
        name= _ "knockback"+" {DISTANCE}"
        description=_ "When a unit is hit with a knockback attack, it is immediately pushed back"+" {DISTANCE} "+_" hex(es) away from the attacker. Units cannot be knocked back into an occupied hex, out of villages or onto terrain they normally could not move to. Non-flying enemies pushed into lava/chasms will be killed, and ones pushed into a wall will receive impact damage. The ability also slows the target for one turn. Knocking an enemy into another enemy slows them both."
        distance={DISTANCE}
    [/spartan_knockback]
#enddef

#using macro to make it easier to keep the code consistent for offense/defense

#extra code start/end is to make lesser knockback use the same macro

#define SPARTAN_KNOCKBACK_EVENT NAME ID FILTER UNITVAR OTHER_UNITVAR WEAPONVAR SPECIAL_TAG_NAME KNOCKBACKER_X KNOCKBACKER_Y TARGET_X TARGET_Y EXTRA_CODE_START EXTRA_CODE_END
[event]
    name={NAME}
    id=spartan_knockback_{ID}
    first_time_only=no

    {FILTER}

    {EXTRA_CODE_START}

    #not needed due to 0 base damage now
    #    [if]
    #        [variable]
    #            name={WEAPONVAR}.damage
    #            less_than=2
    #        [/variable]
    #        [then]
    #            [heal_unit]
    #                [filter]
    #                    id=${OTHER_UNITVAR}.id
    #                [/filter]
    #                amount=1
    #                animate=no
    #                restore_statuses=no
    #            [/heal_unit]
    #    [/then]
    #    [/if]

    #    [if]
    #        [variable]
    #            name={OTHER_UNITVAR}.hitpoints
    #            greater_than=0
    #        [/variable]
    #        [and]
    #        [have_unit]
    #            id=${OTHER_UNITVAR}.id
    #            [not]
    #                ability=knockback_immune
    #            [/not]
    #        [/have_unit]
    #        [/and]
    #
    #        [then]
    {HOPLITE_KNOCKBACK_CODE_REPEATED ${WEAPONVAR}.specials.{SPECIAL_TAG_NAME}.distance {OTHER_UNITVAR} {UNITVAR} -${UNITVAR}.facing}
    #        [/then]
    #    [/if]

    #sweeping/spinning bash filters are now filtered by attack instead of variable
    [if]
        [have_unit]
            id=${UNITVAR}.id
            [has_attack]
                name=${WEAPONVAR}.name
                damage=${WEAPONVAR}.damage
                special_id=spartan_sweepingbash
            [/has_attack]
        [/have_unit]
        [then]
            [store_unit]
                [filter]
                    [filter_side]
                        [enemy_of]
                            side=${UNITVAR}.side
                        [/enemy_of]
                    [/filter_side]
                    [not]
                        ability=knockback_immune
                    [/not]
                    [not]
                        #to prevent accidentally pushing the same target twice
                        id=${OTHER_UNITVAR}.id
                    [/not]
                    [filter_location]
                        [filter_adjacent_location]
                            x,y=${TARGET_X},${TARGET_Y}
                        [/filter_adjacent_location]
                        [filter_adjacent_location]
                            x,y=${KNOCKBACKER_X},${KNOCKBACKER_Y}
                        [/filter_adjacent_location]
                    [/filter_location]
                [/filter]
                variable=bystander
                kill=no
            [/store_unit]
        [/then]
    [/if]

    [if]
        [have_unit]
            id=${UNITVAR}.id
            [has_attack]
                name=${WEAPONVAR}.name
                damage=${WEAPONVAR}.damage
                special_id=spartan_spinningbash
            [/has_attack]
        [/have_unit]
        [then]
            {CLEAR_VARIABLE bystander}
            [store_unit]
                [filter]
                    [filter_side]
                        [enemy_of]
                            side=${UNITVAR}.side
                        [/enemy_of]
                    [/filter_side]
                    [not]
                        ability=knockback_immune
                    [/not]
                    [not]
                        #to prevent accidentally pushing the same target twice
                        id=${OTHER_UNITVAR}.id
                    [/not]
                    [filter_location]
                        [filter_adjacent_location]
                            x,y=${KNOCKBACKER_X},${KNOCKBACKER_Y}
                        [/filter_adjacent_location]
                    [/filter_location]
                [/filter]
                variable=bystander
                kill=no
            [/store_unit]
        [/then]
    [/if]

    [foreach]
        array=bystander
        index_var=a
        [do]
            [if]
                [variable]
                    name=this_item.hitpoints
                    greater_than=0
                [/variable]

                [then]
                    {SPARTAN_GETDIR_REVERSED ${KNOCKBACKER_X} ${KNOCKBACKER_Y} $this_item.x $this_item.y tmp_bystander_dir}
                    #                    [chat]
                    #                        message=$tmp_bystander_dir
                    #                    [/chat]
                    {HOPLITE_KNOCKBACK_CODE_REPEATED ${WEAPONVAR}.specials.{SPECIAL_TAG_NAME}.distance this_item {UNITVAR} $tmp_bystander_dir}

                    {CLEAR_VARIABLE tmp_bystander_dir}
                [/then]
            [/if]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE bystander}

    [if]
    [have_unit]
        id=${OTHER_UNITVAR}.id
        side=$hoplite_playerside
        [and]
            side=$side_number
        [/and]
    [/have_unit]
    [then]
        {VARIABLE tmp_knocked_back_a_player_in_defense yes}
        {VARIABLE tmp_knocked_back_a_player_in_defense_id ${OTHER_UNITVAR}.id}
    [/then]
    [/if]


    {EXTRA_CODE_END}
[/event]
[event]
    name=attack end
    id=spartan_knockback_player_antisoftlock
    first_time_only=no
    priority=-100#runs after most normal "attack end" events to reduce the risk of bugs
    [filter_condition]
        {VARIABLE_CONDITIONAL tmp_knocked_back_a_player_in_defense equals yes}
    [/filter_condition]

    [store_unit]
        [filter]
            id=$tmp_knocked_back_a_player_in_defense_id
        [/filter]
        variable=tmp_knockback_antisoftlock_player
        kill=no
    [/store_unit]

#    [chat]
#        message=_"antisoftlock, id $tmp_knockback_antisoftlock_player.id| moves $tmp_knockback_antisoftlock_player.moves| attacks $tmp_knockback_antisoftlock_player.attacks_left|"
#    [/chat]

    #anti-softlock in case a player melees a defense-knockback unit, so the turn ends:

    [if]
    [have_unit]
        id=$tmp_knocked_back_a_player_in_defense_id
        [not]
            #do not end turn if the player still has hit-and-run or multiple attacks left and can hit something
            formula=($this_unit.moves > 0)
            [or]
                formula=($this_unit.attacks_left > 0)
                [and]
                    [filter_adjacent]
                        side=$hoplite_enemyside
                    [/filter_adjacent]
                [/and]
            [/or]
        [/not]
    [/have_unit]
    [then]
        [end_turn]
        [/end_turn]
    [/then]
    [/if]
    {CLEAR_VARIABLE tmp_knocked_back_a_player_in_defense}
    {CLEAR_VARIABLE tmp_knocked_back_a_player_in_defense_id}
    {CLEAR_VARIABLE tmp_knockback_antisoftlock_player}
[/event]
#enddef


# wmllint: unbalanced-on
# wmlxgettext: [attack]
# wmlxgettext: [specials]
#define WEAPON_SPECIAL_KNOCKBACK DISTANCE
    {SPARTAN_KNOCKBACKSPECIAL {DISTANCE}}
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

{SPARTAN_KNOCKBACK_EVENT (attacker hits) offense (
    [filter_attack]
        special_id=knockback
    [/filter_attack]
) unit second_unit weapon spartan_knockback x1 y1 x2 y2 () ()}

{SPARTAN_KNOCKBACK_EVENT (defender hits) defense (
    [filter_second_attack]
        special_id=knockback
    [/filter_second_attack]
) second_unit unit second_weapon spartan_knockback x2 y2 x1 y1 () ()}

[event]
    name=attack end
    id=spartan_shieldup
    first_time_only=no
    [filter_attack]
        special_id=knockback
    [/filter_attack]
    {VARIABLE shieldup_id $unit.id}
    [fire_event]
        id=hoplite_shieldup
    [/fire_event]
    {CLEAR_VARIABLE shieldup_id}
[/event]
[event]
    id=hoplite_shieldup
    first_time_only=no
    {CHATMSG _"shieldup event"}
    [object]
        silent=yes
        duration=turn
        id=shieldup
        take_only_once=no
        [filter]
            id=$shieldup_id
        [/filter]
        [effect]
            apply_to=new_ability
            [abilities]
                [resistance]
                    id=shieldup_buff
                    add=$shieldup_resistance$side_number
                    max_value=$shieldup_resistance_cap$side_number
                    # applies to any type if we leave it out
                    #apply_to=blade,pierce,impact,fire,cold,arcane
                    [filter_base_value]
                        less_than=$shieldup_resistance_cap$side_number
                    [/filter_base_value]
                    affect_self=yes
                [/resistance]
            [/abilities]
        [/effect]
    [/object]
    {VARIABLE shieldup_active yes}
[/event]

[+attack]
    [+specials]
#enddef
# wmllint: unbalanced-off

#for [effect]s, like when minotaur becomes stronger

#define SPARTAN_LESSERKNOCKBACK DISTANCE
    [spartan_lesser_knockback]
        id=knockback_lesser
        name= _ "lesser knockback"+" {DISTANCE}"
        description=_ "Like knockback, but doesn't slow/pushing into lava doesn't kill, only dealing 10 damage."
        distance={DISTANCE}
    [/spartan_lesser_knockback]
#enddef

# wmllint: unbalanced-on
#define WEAPON_SPECIAL_KNOCKBACK_LESSER DISTANCE
    {SPARTAN_LESSERKNOCKBACK {DISTANCE}}
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

{SPARTAN_KNOCKBACK_EVENT (attacker hits) lesser_offense (
    [filter_attack]
        special_id=knockback_lesser
    [/filter_attack]
) unit second_unit weapon spartan_lesser_knockback x1 y1 x2 y2 (
    {VARIABLE tmp_current_knockback_lesser yes}
) (
    {CLEAR_VARIABLE tmp_current_knockback_lesser}
)}

{SPARTAN_KNOCKBACK_EVENT (defender hits) lesser_defense (
    [filter_second_attack]
        special_id=knockback_lesser
    [/filter_second_attack]
) second_unit unit second_weapon spartan_lesser_knockback x2 y2 x1 y1 (
    {VARIABLE tmp_current_knockback_lesser yes}
) (
    {CLEAR_VARIABLE tmp_current_knockback_lesser}
)}

[+attack]
    [+specials]
#enddef
# wmllint: unbalanced-off

#define ABILITY_LEAPING
    [teleport]
        id=hoplite_leap
        name= _ ""
        female_name= _ ""
        description= _ ""
        [tunnel]
            id=hoplite_leap
            #exclude walls from source/target terrain (chasms are no longer on the list, to ensure the upgrade works properly with levitate/chasm bridges)
            [source]
                terrain=!,Xu*^*,Xo*^*#,Q*^*
                [not]
                    [filter]
                        [not]
                            id=$teleport_unit.id
                        [/not]
                    [/filter]
                [/not]
            [/source]
            [target]
                terrain=!,Xu*^*,Xo*^*#,Q*^*
                [not]
                    [filter]
                    [/filter]
                [/not]
                [and]
                    [filter]
                        id=$teleport_unit.id
                    [/filter]
                    radius=2
                    [filter_radius]
                        terrain=!,Xu*^*,Xo*^*,*^Ftr
                    [/filter_radius]
                [/and]
            [/target]
            [filter]
                ability=hoplite_leap
            [/filter]
        [/tunnel]
    [/teleport]
#enddef

#using different variable substitution, to fix this not working inside menu item
#define ABILITY_LEAPING2
    [teleport]
        id=hoplite_leap
        name= _ ""
        female_name= _ ""
        description= _ ""
        [tunnel]
            id=hoplite_leap
            [source]
                terrain=!,Xu*^*,Xo*^*#,Q*^*
                [not]
                    [filter]
                        [not]
                            id=$|teleport_unit.id
                        [/not]
                    [/filter]
                [/not]
            [/source]
            [target]
                terrain=!,Xu*^*,Xo*^*#,Q*^*
                [not]
                    [filter]
                    [/filter]
                [/not]
                [and]
                    [filter]
                        id=$|teleport_unit.id
                    [/filter]
                    radius=2
                    [filter_radius]
                        terrain=!,Xu*^*,Xo*^*,*^Ftr
                    [/filter_radius]
                [/and]
            [/target]
            [filter]
                ability=hoplite_leap
            [/filter]
        [/tunnel]
    [/teleport]
#enddef

#using different variable substitution ($| instead of $), to fix this not working inside menu item
#define ABILITY_HOPLITE_TELEPORTING
    [teleport]
        id=hoplite_teleport
        name= _ ""
        female_name= _ ""
        description= _ ""
        [tunnel]
            id=hoplite_teleport
            [source]
                terrain=!,Xu*^*,Xo*^*#,Q*^*
                [not]
                    [filter]
                        [not]
                            id=$|teleport_unit.id
                        [/not]
                    [/filter]
                [/not]
            [/source]
            [target]
                terrain=!,Xu*^*,Xo*^*#,Q*^*
                [not]
                    [filter]
                    [/filter]
                [/not]
                [and]
                    [filter]
                        id=$|teleport_unit.id
                        #			side=1
                    [/filter]
                    radius=$|hoplite_teleport_radius$|teleport_unit.side
                    [filter_radius]
                        terrain=!,None
                    [/filter_radius]
                    #		    [or]
                    #                    [filter]
                    #                        id=$|teleport_unit.id
                    #			side=2
                    #                    [/filter]
                    #                    radius=$|hoplite_teleport_radius2
                    #                    [filter_radius]
                    #                        terrain=!,None
                    #                    [/filter_radius]
                    #		    [/or]
                [/and]
            [/target]
            [filter]
                ability=hoplite_teleport
            [/filter]
        [/tunnel]
    [/teleport]
#enddef

# wmllint: unbalanced-on
#define ABILITY_LEAP
    [dummy]
        id=hoplite_leap_dummy
        name= _ "leap"
        description=_ "Right-click this unit to grant a temporary ability to move 2 hexes in one turn for a turn. Costs 50 energy, Energy is replenished by killing enemies, and descending into lower depths."
    [/dummy]
[/abilities]
[event]
    name=start
    id=spartan_leapmenu
    [set_menu_item]
        id=hoplite_leap
        description=_"Leap: Costs <span color='#2c9fed'>50</span> energy."
        image="misc/icon_leap.png"
        [show_if]
            [have_unit]
                id=Hoplite,Hoplite2
                x,y=$x1,$y1
                side=$side_number
                formula="moves > 0"
                [not]
                    ability=hoplite_leap
                    #                    [filter_wml]
                    #                        variation=leaping
                    #                    [/filter_wml]
                    #                    [or]
                    #                        [filter_wml]
                    #                            variation=leaping_spearless
                    #                        [/filter_wml]
                    #                    [/or]
                [/not]
            [/have_unit]
            {VARIABLE_CONDITIONAL teleport_unlocked$side_number not_equals yes}
        [/show_if]
        [command]
            [if]
                [have_unit]
                    id=Hoplite
                    side=$side_number
                [/have_unit]
                [and]
                    [variable]
                        name=hoplite_energy1
                        greater_than_equal_to=50
                    [/variable]
                [/and]
                [or]
                    [have_unit]
                        id=Hoplite2
                        side=$side_number
                    [/have_unit]
                    [and]
                        [variable]
                            name=hoplite_energy2
                            greater_than_equal_to=50
                        [/variable]
                    [/and]
                [/or]
                [then]
                    {HOPLITE_ADD_ENERGY_BY_SIDE $side_number -50}
                    [object]
                        silent=yes
                        duration=turn end
                        [filter]
                            side=$side_number
                            canrecruit=yes
                        [/filter]
                        [effect]
                            apply_to=new_ability
                            [abilities]
                                {ABILITY_LEAPING2}
                            [/abilities]
                        [/effect]
                        [effect]
                            apply_to=new_animation
                            [animation]
                                apply_to=pre_teleport
                                [frame]
                                    duration=300
                                    offset=0.0~1.0:300
                                    y=0~-25:300
                                    sound={SOUND_LIST:MISS}
                                [/frame]
                            [/animation]
                            [animation]
                                apply_to=post_teleport
                                [frame]
                                    duration=300
                                    offset=-1.0~0.0:300
                                    y=-25~0:300
                                [/frame]
                            [/animation]
                        [/effect]
                    [/object]
                    [if]
                        [variable]
                            name=swordlunge_unlocked$side_number
                            equals=yes
                        [/variable]
                        [then]
                            {IF_VAR hoplite_artifacts equals yes (
                                [then]
                                    {VARIABLE tmp_swordlunge_damage_bonus 7}
                                [/then]
                                [else]
                                    {VARIABLE tmp_swordlunge_damage_bonus 5}
                                [/else]
                            )}
                            [object]
                                silent=yes
                                duration=turn end
                                [filter]
                                    side=$side_number
                                    canrecruit=yes
                                [/filter]
                                [effect]
                                    apply_to=attack
                                    name=sword
                                    [not]
                                        special_id=spartan_dummy_swordlunge_effect
                                    [/not]
                                    increase_damage=$tmp_swordlunge_damage_bonus
                                    #prevent lunge damage stacking via a dummy weapon special
                                    [set_specials]
                                        mode=append
                                        [dummy]
                                            id=spartan_dummy_swordlunge_effect
                                        [/dummy]
                                    [/set_specials]
                                [/effect]
                            [/object]
                            {CLEAR_VARIABLE tmp_swordlunge_damage_bonus}
                        [/then]
                    [/if]
                    [print]
                        text= _ "Leap activated!"
                        size=20
                        blue=255
                        duration=2000
                    [/print]
                [/then]
                [else]
                    [print]
                        text= _ "Not enough energy!"
                        size=20
                        red=255
                        duration=2000
                    [/print]
                [/else]
            [/if]
        [/command]
    [/set_menu_item]
    [set_menu_item]
        id=hoplite_teleport
        description=_"Teleport: Costs <span color='#2c9fed'>50</span> energy."
        image="misc/icon_teleport.png"
        [show_if]
            [have_unit]
                id=Hoplite,Hoplite2
                x,y=$x1,$y1
                formula="moves > 0"
                [not]
                    ability=hoplite_teleport
                [/not]
            [/have_unit]
            {VARIABLE_CONDITIONAL teleport_unlocked$side_number equals yes}
        [/show_if]
        [command]
            [if]
                [have_unit]
                    id=Hoplite
                    side=$side_number
                [/have_unit]
                [and]
                    [variable]
                        name=hoplite_energy1
                        greater_than_equal_to=50
                    [/variable]
                [/and]
                [or]
                    [have_unit]
                        id=Hoplite2
                        side=$side_number
                    [/have_unit]
                    [and]
                        [variable]
                            name=hoplite_energy2
                            greater_than_equal_to=50
                        [/variable]
                    [/and]
                [/or]
                [then]
                    {HOPLITE_ADD_ENERGY_BY_SIDE $side_number -50}
                    [object]
                        silent=yes
                        duration=turn end
                        [filter]
                            side=$side_number
                            canrecruit=yes
                        [/filter]
                        [effect]
                            apply_to=new_ability
                            [abilities]
                                {ABILITY_HOPLITE_TELEPORTING}
                            [/abilities]
                        [/effect]
                        [effect]
                            apply_to=new_animation
                            {HOPLITE_TELEPORTANIM}
                        [/effect]
                    [/object]
                    [if]
                        [variable]
                            name=swordlunge_unlocked$side_number
                            equals=yes
                        [/variable]
                        [then]
                            {IF_VAR hoplite_artifacts equals yes (
                                [then]
                                    {VARIABLE tmp_swordlunge_damage_bonus 7}
                                [/then]
                                [else]
                                    {VARIABLE tmp_swordlunge_damage_bonus 5}
                                [/else]
                            )}
                            [object]
                                silent=yes
                                duration=turn end
                                [filter]
                                    side=$side_number
                                    canrecruit=yes
                                [/filter]
                                [effect]
                                    apply_to=attack
                                    name=sword
                                    [not]
                                        special_id=spartan_dummy_swordlunge_effect
                                    [/not]
                                    increase_damage=$tmp_swordlunge_damage_bonus
                                    #prevent lunge damage stacking via a dummy weapon special
                                    [set_specials]
                                        mode=append
                                        [dummy]
                                            id=spartan_dummy_swordlunge_effect
                                        [/dummy]
                                    [/set_specials]
                                [/effect]
                            [/object]
                            {CLEAR_VARIABLE tmp_swordlunge_damage_bonus}
                        [/then]
                    [/if]
                    [print]
                        text= _ "Teleport activated!"
                        size=20
                        blue=255
                        duration=2000
                    [/print]
                    {ALGADUR_LINE teleport (
                        [message]
                            speaker=Algadur
                            # wmllint: local spelling Pfah
                            message=_"I--What!? I have to break me back running to keep up with ye and ye just teleport!? Pfah, at least it's useful"
                        [/message]
                    )}
                    {ELIZABETH_MAGIC_LINE teleport (
                        [message]
                            speaker=Elizabeth
                            message=_"Teleportation!? It took me years to learn the secrets of the Silver Magi..! You're something else."
                        [/message]
                    )}
                [/then]
                [else]
                    [print]
                        text= _ "Not enough energy!"
                        size=20
                        red=255
                        duration=2000
                    [/print]
                [/else]
            [/if]
        [/command]
    [/set_menu_item]
[/event]
[+abilities]
#enddef

#define WEAPON_SPECIAL_SPEARTHROW
    [dummy]
        id=hoplite_spear_throw
        name= _ "spear throw"
        description=_ "Right-click and enemy to throw your spear at it. While the spear is thrown, it deals damage and slows, but you will be unable to use your spear melee, forcing you to rely on other weapons in your arsenal. This attack has a 3-tile range by default, but that can be increased with upgrades."
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring
[event]
    name=start
    [set_menu_item]
        id=hoplite_spear
        description=_"Throw your spear"
        image="misc/icon_spear.png"
        [show_if]
            [have_unit]
                side=$hoplite_enemyside
                x,y=$x1,$y1
                [filter_location]
                    [filter]
                        side=$side_number
                        canrecruit=yes
                        formula="attacks_left > 0"#to prevent the spear throw being usable while having the Persuasive Pacifist pact
                        [not]
                            variation=spearless
                        [/not]
                        [has_attack]
                            special_id=hoplite_spear_throw
                        [/has_attack]
                    [/filter]
                    radius=$hoplite_spearthrow_radius$side_number
                    [filter_radius]
                        [not]
                            terrain=Xu*^*,Xo*^*
                        [/not]
                    [/filter_radius]
                [/filter_location]
            [/have_unit]
        [/show_if]
        [command]
            [store_locations]
                x,y=$x1,$y1
                variable=spearhex
            [/store_locations]
            #spear can now be thrown on any terrain
            #            {IF_VAR spearhex.terrain not_equals Qlf (
            #                [and]
            #                    [variable]
            #                        name=spearhex.terrain
            #                        not_equals=Wwg
            #                    [/variable]
            #                [/and]
            #                [and]
            #                    [variable]
            #                        name=spearhex.terrain
            #                        not_equals=Wog
            #                    [/variable]
            #                [/and]
            #                [and]
            #                    [variable]
            #                        name=spearhex.terrain
            #                        not_equals=Qxua
            #                    [/variable]
            #                [/and]
            #                [then]
            [store_unit]
                [filter]
                    id=Hoplite,Hoplite2
                    side=$side_number
                [/filter]
                variable=spearthrow
                kill=no
            [/store_unit]
            [unstore_unit]
                variable=spearthrow
            [/unstore_unit]
            {VARIABLE isspearthrowing yes}

            {SPARTAN_RETURN_ATTACK_INDEX_BY_NAME spearthrow spear2}

            [animate_unit]
                flag=attack
                hits=yes
                [filter]
                    id=Hoplite,Hoplite2
                    side=$side_number
                [/filter]
                [facing]
                    x,y=$x1,$y1
                [/facing]
                [primary_attack]
                    range=ranged
                    type=pierce
                [/primary_attack]
            [/animate_unit]
            #animation event:
            [fire_event]
                id=spearexplode
                [primary_unit]
                    x,y=$x1,$y1
                [/primary_unit]
            [/fire_event]

            {SPARTAN_CALCULATE_DAMAGE spearthrow $spearthrow.attack[$tmp_index_return].damage}
            {SPARTAN_HIT_BOSS_KILLSTREAK_AND_ENERGY $side_number (x,y=$x1,$y1)}
            {SPARTAN_ATTACKER_UNCOVER_INVISIBILITY id=$spearthrow.id}
            [spartan_harm_unit]
                [filter]
                    x,y=$x1,$y1
                [/filter]
                [filter_second]
                    id=Hoplite,Hoplite2
                    side=$side_number
                [/filter_second]
                #                        [primary_attack]
                #                            range=ranged
                #                            type=pierce
                #                        [/primary_attack]
#                amount=$spearthrow.attack[3].damage
                amount=$tmp_spartan_calculated_damage
                damage_type=pierce
                #		slowed=yes
                fire_event=yes
                animate=defender
                delay=0
                experience=yes
            [/spartan_harm_unit]
            {CLEAR_VARIABLE isspearthrowing}
            #                    {IF_VAR spearthrowexplode_unlocked$side_number equals yes (
            [if]
                [have_unit]
                    id=Hoplite,Hoplite2
                    side=$side_number
                    ability=spartan_skill_used_explosive_spear
                [/have_unit]
                [then]
#                    {VARIABLE halfdmg $spearthrow.attack[3].damage}
                    {VARIABLE halfdmg $tmp_spartan_calculated_damage}
                    {VARIABLE_OP halfdmg divide 2}
                    {VARIABLE_OP halfdmg round ceiling}
                    [spartan_harm_unit]
                        [filter]
                            side=$hoplite_enemyside
                            [filter_location]
                                x,y=$x1,$y1
                                radius=1
                            [/filter_location]
                            [not]
                                x,y=$x1,$y1
                            [/not]
                        [/filter]
                        [filter_second]
                            id=Hoplite,Hoplite2
                            side=$side_number
                        [/filter_second]
                        [primary_attack]
                            name=spear2
                        [/primary_attack]
                        amount=$halfdmg
                        damage_type=fire
                        #		slowed=yes
                        fire_event=yes
                        animate=defender
                        delay=0
                        experience=yes
                    [/spartan_harm_unit]
                    {CLEAR_VARIABLE halfdmg}
                [/then]
                #                    )}
            [/if]

            {CLEAR_VARIABLE tmp_spartan_calculated_damage}

            #			[message]
            #			    speaker=narrator
            #			    message=_"hoplite_nospear: $hoplite_nospear|"#debug
            #			[/message]
            #			[message]
            #			    speaker=narrator
            #			    message=_"hoplite_spear_on_ground: $hoplite_spear_on_ground|"#debug
            #			[/message]
            {IF_VAR hoplite_depthdescending not_equals yes (
                [then]
                    {VARIABLE hoplite_spear_on_ground$side_number yes}
                    [if]
                        [have_unit]
                            id=Hoplite2
                        [/have_unit]
                        [then]
                            {HOPLITE_PLAYERFILTER (
                                {IF_VAR hoplite_artifacts equals yes (
                                    [then]
                                        {VARIABLE spearimg "items/spear-ares.png"}
                                    [/then]
                                    [else]
                                        {VARIABLE spearimg "items/spear-red.png"}
                                    [/else]
                                )}
                            ) (
                                {IF_VAR hoplite_artifacts equals yes (
                                    [then]
                                        {VARIABLE spearimg "items/spear-ares-teal.png"}
                                    [/then]
                                    [else]
                                        {VARIABLE spearimg "items/spear-teal.png"}
                                    [/else]
                                )}
                            )}
                        [/then]
                        [else]
                            {VARIABLE hoplite_spear_on_ground yes}
                            {IF_VAR hoplite_artifacts equals yes (
                                [then]
                                    {VARIABLE spearimg "items/spear-ares.png"}
                                [/then]
                                [else]
                                    {VARIABLE spearimg "items/spear.png"}
                                [/else]
                            )}
                        [/else]
                    [/if]
                    [set_variables]
                        name=hoplite_spearloc$side_number
                        mode=append
                        [value]
                            x=$x1
                            y=$y1
                        [/value]
                    [/set_variables]

                    [item]
                        x,y=$x1,$y1
                        image=$spearimg
                        name=hoplite_spear$side_number
                    [/item]
                    {CLEAR_VARIABLE spearimg}

                    {SPARTAN_CHANGE_VARIATION_PRESERVING_HP_EXACT (
                        side=$side_number
                        canrecruit=yes
                    ) spearless}

                    #pre-nerf code:
                    #{IF_VAR spearthrowexplode_unlocked equals yes (
                    #    [or]
                    #        {HOPLITE_PLAYERFILTER_VAR2 (
                    #            {VARIABLE_CONDITIONAL spearthrowexplode_unlocked1 equals yes}
                    #        ) (
                    #            {VARIABLE_CONDITIONAL spearthrowexplode_unlocked2 equals yes}
                    #        )}
                    #    [/or]
                    #    [then]
                    #        [store_unit]
                    #            [filter]
                    #                side=$hoplite_enemyside
                    #                [filter_location]
                    #                    x,y=$x1,$y1
                    #                    radius=1
                    #                [/filter_location]
                    #            [/filter]
                    #            kill=no
                    #            variable=slowed
                    #        [/store_unit]
                    #    [/then]
                    #    [else]
                    #        [store_unit]
                    #            [filter]
                    #                x,y=$x1,$y1
                    #                side=$hoplite_enemyside
                    #            [/filter]
                    #            kill=no
                    #            variable=slowed
                    #        [/store_unit]
                    #    [/else]
                    #)}

                    [store_unit]
                        [filter]
                            x,y=$x1,$y1
                            side=$hoplite_enemyside
                        [/filter]
                        kill=no
                        variable=slowed
                    [/store_unit]

                    [foreach]
                        array=slowed
                        index_var=a
                        [do]
                            {VARIABLE this_item.status.slowed yes}

                            [unstore_unit]
                                variable=this_item
                                #                  text= _ "Slowed"
                                #                  {COLOR_HARM}
                            [/unstore_unit]
                        [/do]
                    [/foreach]
                [/then]
            )}

            #manually subtract attacks_left, so that it counts as an attack for Rest upgrades

            {MODIFY_UNIT id=$spearthrow.id attacks_left "$($spearthrow.attacks_left - 1)"}

            #old code that just set the values to 0 instead of subtracting 1 attack
            #{MODIFY_UNIT side,canrecruit=$side_number,yes attacks_left 0}
            #{MODIFY_UNIT side,canrecruit=$side_number,yes moves 0}
            [end_turn]
            [/end_turn]


            #        [/else]
            #	[/if]
            #                [/then]
            #                [else]
            #                    [print]
            #                        text= _ "Spear can't be thrown on this terrain!"
            #                        size=22
            #                        red=255
            #                        duration=2000
            #                    [/print]
            #                [/else]
            #            )}
            {CLEAR_VARIABLE tmp_index_return}
        [/command]
    [/set_menu_item]
[/event]
[event]
    name=moveto
    first_time_only=no
    [filter]
        id=Hoplite,Hoplite2
        [filter_location]
            find_in=hoplite_spearloc$side_number
        [/filter_location]
    [/filter]
    {SPARTAN_CHANGE_VARIATION_PRESERVING_HP_EXACT (
        side=$side_number
        canrecruit=yes
    ) ()}
    #to prevent the "if you select attack before moving onto spear loc, you attack with a different weapon than the one you selected, due to weapon index" bug
    [cancel_action]
    [/cancel_action]

    [remove_item]
        image=hoplite_spear$side_number
        x=0-99
        y=0-99
    [/remove_item]

    {VARIABLE hoplite_spear_on_ground$side_number no}
    {CLEAR_VARIABLE hoplite_spearloc$side_number}
[/event]
[+attack]
    [+specials]
#enddef
# wmllint: unbalanced-off

#define WEAPON_SPECIAL_IMPALE
    [damage]
        id=hoplite_impale
        name= _ "impale"
        description=_ "When an enemy is killed by this attack, unit behind the primary target also receives the attack damage. This doesn't chain onto other units."
    [/damage]
#enddef

#define WEAPON_SPECIAL_IMPALEII
    [damage]
        id=hoplite_impale
    [/damage]
    [damage]
        id=hoplite_impaleII
        name= _ "impale II"
        description=_ "When an enemy is killed by this attack, unit behind the primary target also receives the attack damage. This doesn't chain onto other units. Additionally, if the attacked enemy survives the hit, they will deal 33% less damage for one turn."
    [/damage]
#enddef

#define WEAPON_SPECIAL_IMPALEIII
    [damage]
        id=hoplite_impale
    [/damage]
    [damage]
        id=hoplite_impaleII
    [/damage]
    [damage]
        id=hoplite_impaleIII
        name= _ "impale III"
        description=_ "When an enemy is killed by this attack, unit behind the primary target also receives the attack damage. This doesn't chain onto other units. If there isn't an enemy behind the killed target, the enemy behind you gets attacked instead. Additionally, if the attacked enemy survives the hit, they will deal 33% less damage for one turn."
    [/damage]
#enddef
#define HOPLITE_ABILITY_EVENTS
    [event]
        name=last breath
        id=hoplite_impale
        first_time_only=no

        [filter_second_attack]
            special_id=hoplite_impale
        [/filter_second_attack]

        [if]
            [have_unit]
                [filter_side]
                    [enemy_of]
                        side=$second_unit.side
                    [/enemy_of]
                [/filter_side]
                [filter_location]
                    [filter_adjacent_location]
                        x,y=$x1,$y1
                        adjacent=$unit.facing
                    [/filter_adjacent_location]
                [/filter_location]
            [/have_unit]
            [then]
                [store_locations]
                    [filter_adjacent_location]
                        x,y=$x1,$y1
                        adjacent=$unit.facing
                    [/filter_adjacent_location]
                    include_borders=no
                    variable=next_target
                [/store_locations]

                {VARIABLE impaledmg $second_weapon.damage}

                [if]
                    {VARIABLE_CONDITIONAL second_unit.status.slowed boolean_equals yes}
                    [then]
                        {VARIABLE_OP impaledmg divide 2}
                    [/then]
                [/if]

                {VARIABLE_OP impaledmg round ceiling}

                #second unit:
                [spartan_harm_unit]
                    [filter]
                        x,y=$next_target[0].x,$next_target[0].y
                        [filter_side]
                            [enemy_of]
                                side=$second_unit.side
                            [/enemy_of]
                        [/filter_side]
                        [not]
                            [filter_wml]
                                [status]
                                    petrified=yes
                                [/status]
                            [/filter_wml]
                        [/not]
                    [/filter]
                    [filter_second]
                        x,y=$x2,$y2
                    [/filter_second]
                    amount=$impaledmg
                    damage_type=$second_weapon.type
                    alignment=$second_unit.alignment
                    fire_event=yes
                    animate=defender
                    delay=0
                    experience=no
                [/spartan_harm_unit]
                #scrapped:
                #		{VARIABLE_OP impale_progress add 1}
                #		{IF_VAR impale_progress equals 50 (
                #		[then]
                #                {ACHIEVEMENT_MESSAGE impale}
                #		[/then])}

                {CLEAR_VARIABLE impaledmg}
            [/then]
            [elseif]
                [variable]
                    name=impaleIII_unlocked$second_unit.side
                    equals=yes
                [/variable]
                [then]
                    [store_locations]
                        [filter_adjacent_location]
                            x,y=$x2,$y2
                            adjacent=$second_unit.facing
                        [/filter_adjacent_location]
                        include_borders=no
                        variable=next_target
                    [/store_locations]

                    {VARIABLE impaledmg $second_weapon.damage}

                    [if]
                        {VARIABLE_CONDITIONAL second_unit.status.slowed boolean_equals yes}
                        [then]
                            {VARIABLE_OP impaledmg divide 2}
                        [/then]
                    [/if]

                    {VARIABLE_OP impaledmg round ceiling}

                    #second unit:
                    [spartan_harm_unit]
                        [filter]
                            x,y=$next_target[0].x,$next_target[0].y
                            [filter_side]
                                [enemy_of]
                                    side=$second_unit.side
                                [/enemy_of]
                            [/filter_side]
                            [not]
                                [filter_wml]
                                    [status]
                                        petrified=yes
                                    [/status]
                                [/filter_wml]
                            [/not]
                        [/filter]
                        [filter_second]
                            x,y=$x2,$y2
                        [/filter_second]
                        [primary_attack]
                            special_id=hoplite_impale
                        [/primary_attack]
                        amount=$impaledmg
                        damage_type=$weapon.type
                        alignment=$unit.alignment
                        fire_event=yes
                        animate=yes
                        delay=0
                        experience=no
                    [/spartan_harm_unit]

                    {CLEAR_VARIABLE impaledmg}
                [/then]
            [/elseif]
        [/if]
    [/event]
    [event]
        name=attacker hits
        id=hoplite_impaleII
        first_time_only=no

        [filter_attack]
            special_id=hoplite_impaleII
        [/filter_attack]
        [object]
            silent=yes
            duration=turn end
            [filter]
                find_in=second_unit
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    [leadership]
                        id=impaled
                        value=-33
                        cumulative=no
                        affect_self=yes
                    [/leadership]
                [/abilities]
            [/effect]
        [/object]
    [/event]

    #    [event]
    #        name=last breath
    #        first_time_only=no
    #
    #        [filter]
    #            id=Hoplite,Hoplite2
    #            [not]
    #                [filter_wml]
    #                    [status]
    #                        unhealable=yes
    #                    [/status]
    #                [/filter_wml]
    #            [/not]
    #        [/filter]
    #
    #        {IF_VAR phoenixamulet_unlocked equals yes (
    #            [and]
    #                {VARIABLE_CONDITIONAL hoplite_revive_cooldown less_than 1}
    #            [/and]
    #            [or]
    #                {VARIABLE_CONDITIONAL phoenixamulet_unlocked1 equals yes}
    #                [and]
    #                    {VARIABLE_CONDITIONAL hoplite_revive_cooldown1 less_than 1}
    #                [/and]
    #                [and]
    #                    {VARIABLE_CONDITIONAL unit.id equals Hoplite}
    #                [/and]
    #            [/or]
    #            [or]
    #                {VARIABLE_CONDITIONAL phoenixamulet_unlocked2 equals yes}
    #                [and]
    #                    {VARIABLE_CONDITIONAL hoplite_revive_cooldown2 less_than 1}
    #                [/and]
    #                [and]
    #                    {VARIABLE_CONDITIONAL unit.id equals Hoplite2}
    #                [/and]
    #            [/or]
    #            [then]
    #                [sound]
    #                    name={SOUND_LIST:HOLY}
    #                [/sound]
    #                [store_unit]
    #                    [filter]
    #                        x,y=$x1,$y1
    #                    [/filter]
    #                    variable=hoplite_reborn
    #                    kill=no
    #                [/store_unit]
    #                {VARIABLE hoplite_reborn.hitpoints 0}
    #                [unstore_unit]
    #                    variable=hoplite_reborn
    #                    find_vacant=no
    #                [/unstore_unit]
    #                {FLASH_WHITE (
    #                    {IF_VAR phoenixamuletII_unlocked equals yes (
    #                        [or]
    #                            {VARIABLE_CONDITIONAL phoenixamuletII_unlocked1 equals yes}
    #                            [and]
    #                                {VARIABLE_CONDITIONAL unit.id equals Hoplite}
    #                            [/and]
    #                        [/or]
    #                        [or]
    #                            {VARIABLE_CONDITIONAL phoenixamuletII_unlocked2 equals yes}
    #                            [and]
    #                                {VARIABLE_CONDITIONAL unit.id equals Hoplite2}
    #                            [/and]
    #                        [/or]
    #                        [then]
    #                            [heal_unit]
    #                                [filter]
    #                                    x,y=$x1,$y1
    #                                [/filter]
    #                                amount=$healpotion_restore
    #                                animate=yes
    #                                restore_statuses=no
    #                            [/heal_unit]
    #                            [modify_unit]
    #                                [filter]
    #                                    x,y=$x1,$y1
    #                                [/filter]
    #                                [status]
    #                                    poisoned=no
    #                                [/status]
    #                            [/modify_unit]
    #                            [if]
    #                                [have_unit]
    #                                    id=Hoplite2
    #                                [/have_unit]
    #                                [then]
    #                                    {HOPLITE_PLAYERFILTER_X1_Y1 (
    #                                        {VARIABLE_OP hoplite_energy1 add 75}
    #                                        {IF_VAR hoplite_energy1 greater_than $hoplite_maxenergy1 (
    #                                            [then]
    #                                                {VARIABLE hoplite_energy1 $hoplite_maxenergy1}
    #                                            [/then]
    #                                        )}
    #                                        {SET_LABEL 9 1 "Side 1 Energy: $hoplite_energy1|/$hoplite_maxenergy1|"}
    #                                    ) (
    #                                        {VARIABLE_OP hoplite_energy2 add 75}
    #                                        {IF_VAR hoplite_energy2 greater_than $hoplite_maxenergy2 (
    #                                            [then]
    #                                                {VARIABLE hoplite_energy2 $hoplite_maxenergy2}
    #                                            [/then]
    #                                        )}
    #                                        {SET_LABEL 10 1 "Side 2 Energy: $hoplite_energy2|/$hoplite_maxenergy2|"}
    #                                    )}
    #                                [/then]
    #                                [else]
    #                                    {VARIABLE_OP hoplite_energy add 75}
    #                                    {IF_VAR hoplite_energy greater_than $hoplite_maxenergy (
    #                                        [then]
    #                                            {VARIABLE hoplite_energy $hoplite_maxenergy}
    #                                        [/then]
    #                                    )}
    #                                    {SET_LABEL 10 1 "Energy: $hoplite_energy|/$hoplite_maxenergy|"}
    #                                [/else]
    #                            [/if]
    #                        [/then]
    #                        [else]
    #                            [heal_unit]
    #                                [filter]
    #                                    x,y=$x1,$y1
    #                                [/filter]
    #                                amount=10
    #                                animate=yes
    #                                restore_statuses=yes
    #                            [/heal_unit]
    #                        [/else]
    #                    )}
    #                    #	[delay]
    #                    #	  time=500
    #                    #	[/delay]
    #                    [sound]
    #                        name=fire.wav
    #                    [/sound]
    #                    [spartan_harm_unit]
    #                        [filter]
    #                            side=$hoplite_enemyside
    #                            [filter_adjacent]
    #                                x,y=$x1,$y1
    #                            [/filter_adjacent]
    #                        [/filter]
    #                        [filter_second]
    #                            x,y=$x1,$y1
    #                        [/filter_second]
    #                        amount=10
    #                        damage_type=fire
    #                        alignment=$unit.alignment
    #                        fire_event=yes
    #                        animate=no
    #                        delay=0
    #                        experience=no
    #                    [/spartan_harm_unit]
    #                    [store_unit]
    #                        [filter]
    #                            side=$hoplite_enemyside
    #                        [/filter]
    #
    #                        kill=no
    #                        variable=slowed
    #                    [/store_unit]
    #
    #                    [foreach]
    #                        array=slowed
    #                        index_var=a
    #                        [do]
    #                            {VARIABLE this_item.status.slowed yes}
    #                            [unstore_unit]
    #                                variable=this_item
    #                            [/unstore_unit]
    #                        [/do]
    #                    [/foreach]
    #                )}
    #                [if]
    #                    [have_unit]
    #                        id=Hoplite2
    #                    [/have_unit]
    #                    [then]
    #                        {HOPLITE_PLAYERFILTER_X1_Y1 (
    #			{IF_VAR amuletcharge_unlocked1 equals yes (
    #			[then]
    #                            {VARIABLE hoplite_revive_cooldown1 2}
    #			[/then]
    #			[else]
    #                            {VARIABLE hoplite_revive_cooldown1 3}
    #			[/else])}
    #                        ) (
    #			{IF_VAR amuletcharge_unlocked2 equals yes (
    #			[then]
    #                            {VARIABLE hoplite_revive_cooldown2 2}
    #			[/then]
    #			[else]
    #                            {VARIABLE hoplite_revive_cooldown2 3}
    #			[/else])}
    #                        )}
    #                    [/then]
    #                    [else]
    #			{IF_VAR amuletcharge_unlocked equals yes (
    #			[then]
    #                            {VARIABLE hoplite_revive_cooldown 2}
    #			[/then]
    #			[else]
    #                            {VARIABLE hoplite_revive_cooldown 3}
    #			[/else])}
    #                    [/else]
    #                [/if]
    #                {VARIABLE_OP revive_progress add 1}
    #                {IF_VAR revive_progress equals 5 (
    #                    [then]
    #                        {ACHIEVEMENT_MESSAGE revive}
    #                    [/then]
    #                )}
    #                {CLEAR_VARIABLE hoplite_reborn}
    #            [/then]
    #        )}
    #    [/event]
    [event]
        name=attack
        first_time_only=no
        [filter]
            side=$hoplite_enemyside
        [/filter]
        [filter_second]
            id=Hoplite,Hoplite2
            ability=hoplite_teleportaway
        [/filter_second]

        [store_unit]
            [filter]
                id=Hoplite,Hoplite2
                x,y=$x2,$y2
            [/filter]
            variable=hoplite_teleportloc
            kill=no
        [/store_unit]

        {VARIABLE x2 $hoplite_teleportloc.x}
        {VARIABLE y2 $hoplite_teleportloc.y}
        {VARIABLE teleportaway_cost $weapon.damage}
        {VARIABLE_OP teleportaway_cost divide 10}
        {VARIABLE_OP teleportaway_cost multiply 75}
        {HOPLITE_GET_RESIST_MULT $second_unit.id $weapon.type}
        {VARIABLE_OP teleportaway_cost multiply $tmp_resistmult}
        {VARIABLE_OP teleportaway_cost round floor}
        {CLEAR_VARIABLE hoplite_teleportloc}
        {HOPLITE_TELEPORTAWAY_EVENT $teleportaway_cost (
            x,y=$x2,$y2
        )}
        {CLEAR_VARIABLE teleportaway_cost}
    [/event]
    [event]
        name=attack end
        first_time_only=no
        [filter_second]
            id=Hoplite,Hoplite2
        [/filter_second]
        [fire_event]
            id=hoplite_adrenaline
        [/fire_event]
    [/event]
    #handled slightly differently from enemy shortrange, to make it visible in the interface properly (you can't try to attack enemies outside range)
    [event]
        name=side turn
        id=hoplite_shortrange2_event
        first_time_only=no
        [filter_condition]
            [have_unit]
                side=$side_number
                [has_attack]
                    special_id=shortranged2
                [/has_attack]
            [/have_unit]
        [/filter_condition]
        {CHATMSG "shortranged player event"}
        [store_unit]
            [filter]
                side=$side_number
                canrecruit=yes
            [/filter]
            variable=tmp_shortrange_hoplite
            kill=no
        [/store_unit]
        [object]
            silent=yes
            duration=turn end
            [filter]
                find_in=tmp_shortrange_hoplite
            [/filter]
            [effect]
                apply_to=attack
                special_id=shortranged2
                [set_specials]
                    mode=append
                    [disable]
                        id=shortranged_disableattack
                        [filter_opponent]
                            [not]
                                [filter_location]
                                    x,y=$tmp_shortrange_hoplite.x,$tmp_shortrange_hoplite.y
                                    radius=1
                                [/filter_location]
                            [/not]
                        [/filter_opponent]
                    [/disable]
                [/set_specials]
            [/effect]
        [/object]
        {CLEAR_VARIABLE tmp_shortrange_hoplite}
    [/event]
    [event]
        name=attacker hits
        id=spartan_burn_melee
        first_time_only=no

        [filter_attack]
            special_id=spartan_burn
        [/filter_attack]
        {SPARTAN_APPLY_BURN $weapon.specials.burn.burn_number id=$second_unit.id $unit.id}
    [/event]
    [event]
        name=attacker hits
        id=spartan_sweeping_slow
        first_time_only=no
        [filter_attack]
            special_id=spartan_sweepingslow
        [/filter_attack]

        [modify_unit]
            [filter]
                [filter_side]
                    [enemy_of]
                        side=$unit.side
                    [/enemy_of]
                [/filter_side]
                [filter_adjacent]
                    x,y=$x2,$y2
                [/filter_adjacent]
                [filter_adjacent]
                    x,y=$x1,$y1
                [/filter_adjacent]
                [not]
                    [filter_wml]
                        [status]
                            petrified=yes
                        [/status]
                    [/filter_wml]
                    [or]
                        id=$second_unit.id
                    [/or]
                [/not]
            [/filter]
            [status]
                slowed=yes
            [/status]
        [/modify_unit]
    [/event]
    [event]
        name=attacker hits
        id=spartan_sweeping_long_slow
        first_time_only=no
        [filter_attack]
            special_id=spartan_sweeping_longslow
        [/filter_attack]

        {SPARTAN_APPLY_LONG_SLOW 1 (
            [filter_side]
                [enemy_of]
                    side=$unit.side
                [/enemy_of]
            [/filter_side]
            [filter_adjacent]
                x,y=$x2,$y2
            [/filter_adjacent]
            [filter_adjacent]
                x,y=$x1,$y1
            [/filter_adjacent]
            [not]
                [filter_wml]
                    [status]
                        petrified=yes
                    [/status]
                [/filter_wml]
                [or]
                    id=$second_unit.id
                [/or]
            [/not]
        )}
    [/event]


    {HOPLITE_SLUGGISH_EVENTS}
    {HOPLITE_LEAP_NONPLAYER_EVENTS}
    {SPARTAN_COMBO_EVENTS}
    {HOPLITE_CLEAVE_EVENT}
    {SPARTAN_LONG_SLOW_EVENTS}
#enddef

#define HOPLITE_ADRENALINE_EVENT_OLD FILTER
    {IF_VAR adrenaline_unlocked equals yes (
        [or]
            {VARIABLE_CONDITIONAL adrenaline_unlocked1 equals yes}
            [and]
                [have_unit]
                    id=Hoplite
                    ability=hoplite_adrenaline
                    {FILTER}
                [/have_unit]
            [/and]
        [/or]
        [or]
            {VARIABLE_CONDITIONAL adrenaline_unlocked2 equals yes}
            [and]
                [have_unit]
                    id=Hoplite2
                    ability=hoplite_adrenaline
                    {FILTER}
                [/have_unit]
            [/and]
        [/or]
        [then]
            [if]
                [have_unit]
                    id=Hoplite2
                    ability=hoplite_adrenaline
                    {FILTER}
                [/have_unit]
                [then]
                    [store_unit]
                        [filter]
                            id=Hoplite2
                        [/filter]
                        variable=hoplite_andrenalinerush
                        kill=no
                    [/store_unit]
                [/then]
                [else]
                    [store_unit]
                        [filter]
                            id=Hoplite
                        [/filter]
                        variable=hoplite_andrenalinerush
                        kill=no
                    [/store_unit]
                [/else]
            [/if]
            {VARIABLE andrenalinerushfilter $hoplite_andrenalinerush.max_hitpoints}
            {VARIABLE_OP andrenalinerushfilter divide 2}
            {VARIABLE_OP andrenalinerushfilter round ceiling}
            {IF_VAR hoplite_andrenalinerush.hitpoints greater_than 0 (
                [and]
                    [variable]
                        name=hoplite_andrenalinerush.hitpoints
                        less_than_equal_to=$andrenalinerushfilter
                    [/variable]
                [/and]
                [and]
                    {VARIABLE_CONDITIONAL hoplite_adrenalinerush_cooldown less_than 1}
                    [and]
                        {VARIABLE_CONDITIONAL hoplite_multiplayer not_equals yes}
                    [/and]
                    [or]
                        {VARIABLE_CONDITIONAL hoplite_adrenalinerush_cooldown1 less_than 1}
                        [and]
                            [have_unit]
                                id=Hoplite
                                ability=hoplite_adrenaline
                                {FILTER}
                            [/have_unit]
                        [/and]
                    [/or]
                    [or]
                        {VARIABLE_CONDITIONAL hoplite_adrenalinerush_cooldown2 less_than 1}
                        [and]
                            [have_unit]
                                id=Hoplite2
                                ability=hoplite_adrenaline
                                {FILTER}
                            [/have_unit]
                        [/and]
                    [/or]
                [/and]
                [then]
                    [if]
                        [have_unit]
                            id=Hoplite2
                        [/have_unit]
                        [then]
                            [if]
                                [have_unit]
                                    id=Hoplite
                                    ability=hoplite_adrenaline
                                    {FILTER}
                                [/have_unit]
                                [then]
                                    {VARIABLE_OP hoplite_energy1 add 75}
                                    {IF_VAR hoplite_energy1 greater_than $hoplite_maxenergy1 (
                                        [then]
                                            {VARIABLE hoplite_energy1 $hoplite_maxenergy1}
                                        [/then]
                                    )}
                                    {SET_LABEL 9 1 "Side 1 Energy: $hoplite_energy1|/$hoplite_maxenergy1|"}
                                [/then]
                                [elseif]
                                    [have_unit]
                                        id=Hoplite2
                                        ability=hoplite_adrenaline
                                        {FILTER}
                                    [/have_unit]
                                    [then]
                                        {VARIABLE_OP hoplite_energy2 add 75}
                                        {IF_VAR hoplite_energy2 greater_than $hoplite_maxenergy2 (
                                            [then]
                                                {VARIABLE hoplite_energy2 $hoplite_maxenergy2}
                                            [/then]
                                        )}
                                        {SET_LABEL 10 1 "Side 2 Energy: $hoplite_energy2|/$hoplite_maxenergy2|"}
                                    [/then]
                                [/elseif]
                            [/if]
                        [/then]
                        [else]
                            {VARIABLE_OP hoplite_energy add 75}
                            {IF_VAR hoplite_energy greater_than $hoplite_maxenergy (
                                [then]
                                    {VARIABLE hoplite_energy $hoplite_maxenergy}
                                [/then]
                            )}
                            {SET_LABEL 10 1 "Energy: $hoplite_energy|/$hoplite_maxenergy|"}
                        [/else]
                    [/if]
                    [unstore_unit]
                        variable=hoplite_andrenalinerush
                        text= _ "Adrenaline rush!"
                        blue=255
                    [/unstore_unit]
                    [sound]
                        name=magic-faerirefire.ogg
                    [/sound]
                    {IF_VAR bloodlustIII_unlocked1 equals yes (
                        [then]
                            {IF_VAR bloodlustIII_active1 not_equals yes (
                                [then]
                                    {HOPLITE_RAGE_EVENT Hoplite}
                                    {VARIABLE bloodlustIII_active1 yes}
                                    {VARIABLE hoplite_continue_killstreak_thisturn1 yes}
                                [/then]
                            )}
                        [/then]
                    )}
                    {IF_VAR bloodlustIII_unlocked2 equals yes (
                        [then]
                            {IF_VAR bloodlustIII_active2 not_equals yes (
                                [then]
                                    {HOPLITE_RAGE_EVENT Hoplite2}
                                    {VARIABLE bloodlustIII_active2 yes}
                                    {VARIABLE hoplite_continue_killstreak_thisturn2 yes}
                                [/then]
                            )}
                        [/then]
                    )}
                    [if]
                        [have_unit]
                            id=Hoplite2
                        [/have_unit]
                        [then]
                            [if]
                                [have_unit]
                                    id=Hoplite
                                    ability=hoplite_adrenaline
                                    {FILTER}
                                [/have_unit]
                                [then]
                                    {VARIABLE hoplite_adrenalinerush_cooldown1 1}
                                [/then]
                                [else]
                                    {VARIABLE hoplite_adrenalinerush_cooldown2 1}
                                [/else]
                            [/if]
                        [/then]
                        [else]
                            {VARIABLE hoplite_adrenalinerush_cooldown 1}
                        [/else]
                    [/if]
                [/then]
            )}
        [/then]
    )}
#enddef

#define HOPLITE_TELEPORTAWAY_EVENT ENERGY FILTER
    [if]
        [have_unit]
            id=Hoplite
            ability=hoplite_teleportaway
            [and]
                {FILTER}
            [/and]
        [/have_unit]
        [and]
            [variable]
                name=teleportaway_enabled1
                equals=yes
            [/variable]
        [/and]
        [and]
            [variable]
                name=hoplite_energy1
                greater_than_equal_to={ENERGY}
            [/variable]
        [/and]
        [or]
            [have_unit]
                id=Hoplite2
                ability=hoplite_teleportaway
                [and]
                    {FILTER}
                [/and]
            [/have_unit]
            [and]
                [variable]
                    name=teleportaway_enabled2
                    equals=yes
                [/variable]
            [/and]
            [and]
                [variable]
                    name=hoplite_energy2
                    greater_than_equal_to={ENERGY}
                [/variable]
            [/and]
        [/or]
        [then]
            [if]
                [have_unit]
                    id=Hoplite2
                    {FILTER}
                [/have_unit]
                [then]
                    {HOPLITE_ADD_ENERGY_BY_SIDE 2 -50}
                [/then]
                [else]
                    {HOPLITE_ADD_ENERGY_BY_SIDE 1 -50}
                [/else]
            [/if]
            [sound]
                name=magic-faeriefire.ogg
            [/sound]

            #give the player the teleport anim until the start of next turn:
            [object]
                silent=yes
                duration=turn
                [filter]
                    id=Hoplite,Hoplite2
                    {FILTER}
                [/filter]
                [effect]
                    apply_to=new_animation
                    {HOPLITE_TELEPORTANIM}
                [/effect]
            [/object]
            [animate_unit]
                flag=pre_teleport
                [filter]
                    id=Hoplite,Hoplite2
                    {FILTER}
                [/filter]
            [/animate_unit]
            [store_unit]
                [filter]
                    id=Hoplite,Hoplite2
                    {FILTER}
                [/filter]
                variable=hoplite_stored
                kill=yes
            [/store_unit]
            {SCATTER_UNITS 1 "Hoplite_Dummy_Unit" 2 (
                terrain=Ur*^*,D*^*
                #	    x,y=$hoplite_stored.x,$hoplite_stored.y
                #	    radius=3
                [not]
                    [filter]
                    [/filter]
                    [or]
                        [filter]
                            side=$hoplite_enemyside
                        [/filter]
                        radius=1
                    [/or]
                    [or]
                        y=1-5
                    [/or]
                    [or]
                        {FILTER}
                    [/or]
                [/not]
            ) (
                side=$hoplite_enemyside
            )}
            #adding gradually less strict filters, if the event can't place a dummy unit:
            [if]
                [have_unit]
                    type=Hoplite_Dummy_Unit
                [/have_unit]
                [else]
                    {SCATTER_UNITS 1 "Hoplite_Dummy_Unit" 1 (
                        terrain=Ur*^*,D*^*
                        #       x,y=$hoplite_stored.x,$hoplite_stored.y
                        #       radius=3
                        [not]
                            [filter]
                            [/filter]
                            [or]
                                y=1-3
                            [/or]
                            [or]
                                {FILTER}
                            [/or]
                        [/not]
                    ) (
                        side=$hoplite_enemyside
                    )}
                [/else]
            [/if]
            [if]
                [have_unit]
                    type=Hoplite_Dummy_Unit
                [/have_unit]
                [else]
                    {SCATTER_UNITS 1 "Hoplite_Dummy_Unit" 0 (
                        terrain=Ur*^*,D*^*
                        [not]
                            [filter]
                            [/filter]
                            [or]
                                {FILTER}
                            [/or]
                        [/not]
                    ) (
                        side=$hoplite_enemyside
                    )}
                [/else]
            [/if]
            [store_unit]
                [filter]
                    type=Hoplite_Dummy_Unit
                [/filter]
                variable=hoplite_teleportloc
                kill=yes
            [/store_unit]
            {VARIABLE hoplite_stored.x $hoplite_teleportloc.x}
            {VARIABLE hoplite_stored.y $hoplite_teleportloc.y}
            {CLEAR_VARIABLE hoplite_teleportloc}
            [unstore_unit]
                variable=hoplite_stored
                find_vacant=yes
            [/unstore_unit]
            [animate_unit]
                flag=post_teleport
                [filter]
                    id=$hoplite_stored.id
                [/filter]
            [/animate_unit]
            [store_unit]
                [filter]
                    side=$hoplite_enemyside
                    [filter_location]
                        [filter]
                            id=$hoplite_stored.id
                        [/filter]
                        radius=2
                    [/filter_location]
                [/filter]
                kill=no
                variable=slowed
            [/store_unit]

            [foreach]
                array=slowed
                index_var=a
                [do]
                    {VARIABLE this_item.status.slowed yes}
                    [unstore_unit]
                        variable=this_item
                    [/unstore_unit]
                [/do]
            [/foreach]

            {CLEAR_VARIABLE hoplite_teleport}
            {CLEAR_VARIABLE hoplite_stored}
        [/then]
    [/if]
#enddef

#define ABILITY_HOPLITE_KNOCKBACKIMMUNE
    #    [dummy]
    #        id=knockback_immune
    #        name= _ "immune to knockback"
    #        description=_ "This unit is unaffected by the knockback special."
    #    [/dummy]
    #knockback immunity is now technically resist 999, so I no longer need extra filters
    [knockback_resistance]
        #        id=knockback_resistance
        id=knockback_immune
        name= _ "immune to knockback"
        description=_ "This unit is unaffected by the knockback special."
        value=999
    [/knockback_resistance]
#enddef

#define ABILITY_HOPLITE_KNOCKBACKRESIST VALUE
    [knockback_resistance]
        id=knockback_resistance
        name= _ "knockback resistance"+" {VALUE}"
        description=_ "This unit is resistant to knockback (for example, with knockback resistance 1, if a unit would be pushed 2 tiles it is pushed 1 tile instead. If the knockback resistance is equal or higher to the distance that the unit would be pushed, the unit is unaffected by the knockback)."
        value={VALUE}
    [/knockback_resistance]
#enddef

#define ABILITY_HOPLITE_EASY_TO_PUSH
    [knockback_resistance]
        id=knockback_resistance
        name= _ "easy to push"
        description=_ "This unit can be pushed 1 tile further than normal by knockback."
        value=-1
    [/knockback_resistance]
#enddef

#no longer needed
#ifdef __UNUSED__
#define ABILITY_HOPLITE_SWIMMER
    #dummy ability to make the unit not take damage when knocked into water
    [dummy]
        id=hoplite_swimmer
    [/dummy]
#enddef
#endif

#define ABILITY_HOPLITE_FLYING
    #dummy ability to make the unit not take damage when knocked into lava/chasms
    [dummy]
        id=hoplite_flying
    [/dummy]
#enddef

#enemy abilities:
#define WEAPON_SPECIAL_HOPLITE_DISABLEONSLOW
    [disable]
        id=hoplite_disableonslow
        [filter_self]
            [filter_wml]
                [status]
                    slowed=yes
                [/status]
            [/filter_wml]
        [/filter_self]
    [/disable]
#enddef

# wmllint: unbalanced-on
#define SPECIAL_HOPLITE_SHORTRANGED
    [dummy]
        id=shortranged
        name= _ "short-ranged"
        description=_ "This attack can only used if the unit is standing next to the target at the start of the unit's turn."
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring
[event]
    name=moveto
    id=hoplite_shortrange_event
    first_time_only=no
    [filter]
        [has_attack]
            special_id=shortranged
        [/has_attack]
    [/filter]
    #    [chat]
    #        message=$unit.type
    #    [/chat]
    [object]
        silent=yes
        duration=turn
        [filter]
            id=$unit.id
        [/filter]
        [effect]
            apply_to=attack
            special_id=shortranged
            [set_specials]
                mode=append
                [disable]
                    id=shortranged_disableattack
                    [filter_opponent]
                        [not]
                            [filter_location]
                                x,y=$x2,$y2
                                radius=1
                            [/filter_location]
                        [/not]
                    [/filter_opponent]
                [/disable]
            [/set_specials]
        [/effect]
    [/object]
[/event]
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef
# wmllint: unbalanced-off

#define SPECIAL_HOPLITE_LIGHTNINGSTRIKE
    [dummy]
        id=lightningstrike
        name= _ "lightning strike"
        description=_ "This attack can attack any tile. However, it needs one turn to charge up (the target hex is highlighted in red), and can't retarget from the original target location."
    [/dummy]
#enddef

#define SPECIAL_HOPLITE_WEB
    [dummy]
        id=hoplite_web
        name= _ "web spit"
        description=_ "This attack can attack units in a 3-tile line in the direction that the unit is facing. However, the attack can't be used on targets standing directly next to the attacker. It has a 1-turn charge time, and a 1-turn cooldown. The target tiles are highlighted in yellow. On impact, the web deals 1 damage and slows."
    [/dummy]
#enddef

#define SPECIAL_HOPLITE_ARCHERY
    [dummy]
        id=archery
        name= _ "archery"
        description=_ "This attack can attack units in a 4-tile line in the direction that the unit is facing. However, the attack can't be used on targets standing directly next to the attacker. It has a 1-turn charge time, and a 1-turn cooldown. The target tiles are highlighted in yellow."
    [/dummy]
#enddef

#define SPECIAL_HOPLITE_WIZARD_BEAM NUMBER
    [dummy]
        id=hoplite_beam
        name= _ "wizard beam"
        description=_ "This attack can attack units in a "+{NUMBER}+"-tile line in the direction that the unit is facing. It has a 1-turn charge time, and a 1-turn cooldown. The target tiles are highlighted in red."
    [/dummy]
#enddef

#define SPECIAL_HOPLITE_EXPLOSION
    [dummy]
        id=hoplite_explosion
        name= _ "explosion"
        description=_ "This attack targets hexes around a random hex adjacent to an enemy. The targeted hexes are marked with a yellow hexagon."
    [/dummy]
#enddef

#since this macro is used for ranged attacks too

#define SPARTAN_APPLY_CURSE FILTER
    [store_unit]
        [filter]
            {FILTER}
        [/filter]
        variable=tmp_curse_store
        kill=no
    [/store_unit]

    [foreach]
        array=tmp_curse_store
        index_var=i
        [do]
            [floating_text]
                x,y=$this_item.x,$this_item.y
                text=_"<span color='#ff0000'>cursed</span>"
            [/floating_text]
            [if]
                [have_unit]
                    id=$this_item.id
                    [not]
                        [filter_wml]
                            [status]
                                unhealable=yes
                            [/status]
                        [/filter_wml]
                    [/not]
                [/have_unit]
                [then]
                    [object]
                        silent=yes
                        #                duration=scenario
                        duration=turn end
                        id=cursed
                        take_only_once=no
                        [filter]
                            id=$this_item.id
                        [/filter]
                        #                [effect]
                        #                    apply_to=status
                        #                    add=unhealable
                        #                [/effect]
                        [effect]
                            apply_to=new_ability
                            [abilities]
                                [dummy]
                                    id=spartan_keep_unhealable
                                [/dummy]
                            [/abilities]
                        [/effect]
                        [effect]
                            apply_to=image_mod
                            add="CS(-15,-50,0)"
                        [/effect]
                        [effect]
                            apply_to=status
                            add=unhealable
                        [/effect]
                    [/object]
                    [modify_unit]
                        [filter]
                            id=$this_item.id
                        [/filter]
                        [status]
                            unhealable=yes
                        [/status]
                    [/modify_unit]
                    #            [set_variables]
                    #                name=unhealable_unit_information
                    #                mode=append
                    #                [value]
                    #                    id=$second_unit.id
                    #                    side=$second_unit.side
                    #                    turn_of_rehealing=$"($turn_number| + 2)"
                    #                [/value]
                    #            [/set_variables]
                [/then]
            [/if]
        [/do]
    [/foreach]

    {CLEAR_VARIABLE tmp_curse_store}
#enddef

# wmllint: unbalanced-on
#define WEAPON_SPECIAL_HOPLITE_CURSE
    [dummy]
        id=hoplite_unhealable
        name= _ "curse"
        description=_ "When hit with this attack, the target becomes cursed. While under the effect of the curse, the unit becomes unable to use healing potions, and bloodlust II/phoenix amulet effects do not activate. On top of that, the energy gained from kills is halved (rounded down). The effect wears off at the end of the target's turn. Companions who are reduced to 0 hp while cursed take 1 depth longer to respawn."
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring
[event]
    name=attacker_hits
    first_time_only=no
    [filter_attack]
        special_id=hoplite_unhealable
    [/filter_attack]
    {SPARTAN_APPLY_CURSE (id=$second_unit.id)}
[/event]
[event]
    name=defender_hits
    first_time_only=no
    [filter_second_attack]
        special_id=hoplite_unhealable
    [/filter_second_attack]
    {SPARTAN_APPLY_CURSE (id=$unit.id)}
[/event]
[event]
    name=side turn
    id=spartan_clear_curse
    first_time_only=no
    [modify_unit]
        [filter]
            [filter_wml]
                [status]
                    unhealable=yes
                [/status]
                [not]
                    ability=spartan_keep_unhealable
                [/not]
            [/filter_wml]
        [/filter]
        [status]
            unhealable=no
        [/status]
    [/modify_unit]
[/event]
#[event]
#    name=side turn
#    first_time_only=no
#    [filter_condition]
#        {VARIABLE_CONDITIONAL unhealable_unit_information.length greater_than 0}
#    [/filter_condition]
#
#	{CHATMSG "unhealable_unit_information"}
#
#    [foreach]
#        array=unhealable_unit_information
#        index_var=i
#        [do]
#
#        [if]
#            [variable]
#                name=turn_number
#                greater_than_equal_to=$this_item.turn_of_rehealing
#            [/variable]
#            [and]
#                [variable]
#                    name=this_item.side
#                    equals=$side_number
#                [/variable]
#            [/and]
#
#            [then]
#                [remove_object]
#                    id=$this_item.id
#                    object_id=cursed
#                [/remove_object]
#                [modify_unit]
#                [filter]
#                    id=$this_item.id
#                [/filter]
#                [status]
#                    unhealable=no
#                [/status]
#                [/modify_unit]
#                [clear_variable]
#                    name=this_item
#                [/clear_variable]
#            [/then]
#        [/if]
#
#        [/do]
#    [/foreach]
#[/event]
[+attack]
    [+specials]
#enddef
# wmllint: unbalanced-off

#define ABILITY_TELEPORTAWAY
    [dummy]
        id=teleportaway
        name= _ "teleport away"
        description=_ "This unit teleports to a random location after being attacked."
    [/dummy]
#enddef

#define ABILITY_SPARTAN_COWARDLY
    [dummy]
        id=spartan_cowardly
        name= _ "cowardly"
        description=_ "This unit tries to keep a safe distance from enemies, and only attacks if cornered (unable to move, or there's an enemy next to the hex retreated to)."
    [/dummy]
#enddef

#stronger version of cowardly (enemies run farther away), currently used for Curse of Fear:

#define ABILITY_SPARTAN_TERRIFIED
    [dummy]
        id=spartan_terrified
        name= _ "terrified"
        description=_ "This unit tries to run far away from enemies, and only attacks if cornered (unable to move, or there's an enemy next to the hex retreated to)."
    [/dummy]
#enddef

#define ABILITY_HOPLITE_BOSS_IMMUNITIES
    #for enthrall/avoiding lava/chasm instakills. split so that it can be given to stuff like reaper clones/other stuff that should be immune to instakills/enthrall but shouldn't drop orbs/count for achievements
    [dummy]
        id=hoplite_boss_immunities
    [/dummy]
#enddef

#define ABILITY_HOPLITE_BOSS_STAT_MULTIPLIER
    #also for reaper clones
    [dummy]
        id=hoplite_boss_statmultiplier
    [/dummy]
#enddef

#define ABILITY_HOPLITE_BOSS ID
    #for filtering bosses
    [hoplite_boss]
        id=hoplite_boss
        name=_"boss"
        description=_"This unit can't be instantly killed by being knocked into lava (takes damage instead), and can't be enthralled. However, this unit drops an Orb of Insight when killed."
        is_boss=yes#used for filtering bosses via variable, when a boss is dead and [have_unit] is useless
        boss_ability_id={ID}#used for filtering the same boss but with different unit types (multiphase bosses)
    [/hoplite_boss]
    {ABILITY_HOPLITE_BOSS_IMMUNITIES}
    {ABILITY_HOPLITE_BOSS_STAT_MULTIPLIER}
#enddef

#define SPARTAN_GHOSTLY_FILTER SELF_SIDES
    side={SELF_SIDES}
    [filter_location]
        [not]
            [filter]
                [filter_side]
                    [enemy_of]
                        side={SELF_SIDES}
                    [/enemy_of]
                [/filter_side]
            [/filter]
            radius=2
            [filter_radius]
                [not]
                    terrain=Xu*^*,Xo*^*
                [/not]
            [/filter_radius]
        [/not]
        [not]
            [filter]
                [filter_side]
                    [enemy_of]
                        side={SELF_SIDES}
                    [/enemy_of]
                [/filter_side]
                ability=hoplite_lantern
            [/filter]
            radius=3
            [filter_radius]
                [not]
                    terrain=Xu*^*,Xo*^*
                [/not]
            [/filter_radius]
        [/not]
        [not]
            [filter]
                [filter_side]
                    [enemy_of]
                        side={SELF_SIDES}
                    [/enemy_of]
                [/filter_side]
                ability=hoplite_lantern2
            [/filter]
            radius=4
            [filter_radius]
                [not]
                    terrain=Xu*^*,Xo*^*
                [/not]
            [/filter_radius]
        [/not]
    [/filter_location]
#enddef


#define ABILITY_GHOSTLY
    [hides]
        id=ghostly
        name= _ "ghostly"
        female_name= _ "female^ghostly"
        description= _ "This unit is invisible unless there's an enemy standing in a 2-tile radius near it. (or 3-tile radius for enemies with 'lantern' upgrade or ability)"
        affect_self=yes
        [filter]
            #hacky workaround since I could not get $this_unit to work here
            {SPARTAN_GHOSTLY_FILTER $hoplite_enemyside}
            [or]
            {SPARTAN_GHOSTLY_FILTER $hoplite_playerside,$hoplite_allyside}
            [/or]
        [/filter]
    [/hides]
#enddef

#define SPECIAL_HOPLITE_COUNTERATTACK
    [dummy]
        id=hoplite_counterattack
        name= _ "counterattack"
        description=_ "Unlike most attacks in this campaign, this attack can be used defensively."
    [/dummy]
#enddef

#define ABILITY_HOPLITE_DODGE VALUE
    [chance_to_hit] # this is a weapon special, but as of 1.15.0, it is possible to use it this way in [abilities]
        id=hoplite_dodge{VALUE}
        sub={VALUE}
        name= _ "dodge"+" {VALUE}"
        description= _ "This unit has a"+" {VALUE}% "+_"chance to dodge enemy attacks."
        affect_self=yes
        cumulative=yes
        apply_to=opponent
    [/chance_to_hit]
#enddef

# wmllint: unbalanced-on
#define ABILITY_HOPLITE_SUMMON ID NAME DESCRIPTION TYPES COOLDOWN SUMMONCAP
    #[hoplite_summon_{ID}] is used to make it possible to have multiple summon abilities on one unit just in case
    [hoplite_summon_{ID}]
        id=hoplite_summon_{ID}
        name={NAME}
        #using these params since I decided to give summoning to elizabeth
        #(this allows upgrading summon via replacing the ability in [object])
        description={DESCRIPTION}
        types_list={TYPES}
        cooldown={COOLDOWN}
        summoncap={SUMMONCAP}
    [/hoplite_summon_{ID}]
    [dummy]
        id=summonerfilter
    [/dummy]
[/abilities]
[event]
    #needed, otherwise the moves=0 and attacks_left=0 code below won't work
    #        name=side turn
    name=turn refresh
    first_time_only=no
    id=hoplite_summon_event_{ID}
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_summon_{ID}
            side=$side_number
        [/have_unit]
    [/filter_condition]
    {CHATMSG "summon event {ID}"}

    [store_unit]
        [filter]
            ability=hoplite_summon_{ID}
            side=$side_number
        [/filter]
        variable={ID}
    [/store_unit]
    [foreach]
        array={ID}
        index_var=i
        [do]
            #            #starts on cooldown, to make summoners not too frustrating to fight
            #            {IF_VAR this_item.variables.summon_cooldown not_equals $emptyvar (
            #            [else]
            #                [modify_unit]
            #                    [filter]
            #                        id=$this_item.id
            #                    [/filter]
            #                    [set_variable]
            #                        name=summon_cooldown
            #                        value=$this_item.abilities.hoplite_summon_{ID}.cooldown
            #                    [/set_variable]
            #                [/modify_unit]
            #            [/else]
            #            )}
            [modify_unit]
                [filter]
                    id=$this_item.id
                [/filter]
                [set_variable]
                    name=summon_cooldown_{ID}
                    #                    sub=1
                    add=1#cooldown now counts up instead of down
                [/set_variable]
            [/modify_unit]
            #            {IF_VAR this_item.variables.summon_cooldown greater_than 0 (
            #            [else]
            {IF_VAR this_item.variables.summon_cooldown_{ID} greater_than_equal_to $this_item.abilities.hoplite_summon_{ID}.cooldown (
                [then]
                    {VARIABLE tmp_summoncap ${ID}.length}
                    {VARIABLE_OP tmp_summoncap multiply $this_item.abilities.hoplite_summon_{ID}.summoncap}
                    [store_unit]
                        [filter]
                            ability=summoned_by_{ID}
                        [/filter]
                        variable=tmp_summons
                        kill=no
                    [/store_unit]
                    {IF_VAR tmp_summons.length greater_than_equal_to $tmp_summoncap (
                        [then]
                        [/then]
                        [else]
                            [animate_unit]
                                flag=summon
                                [filter]
                                    id=$this_item.id
                                [/filter]
                            [/animate_unit]
                            {VARIABLE_OP tmp_summontype rand $this_item.abilities.hoplite_summon_{ID}.types_list}
                            [unit]
                                type=$tmp_summontype
                                side=$side_number
                                x,y=$this_item.x,$this_item.y
                                moves=0
                                attacks_left=0
                                animate=yes
                                placement=map
                                passable=yes
                                [modifications]
                                    [object]
                                        silent=yes
                                        duration=scenario
                                        [effect]
                                            apply_to=new_ability
                                            [abilities]
                                                [dummy]
                                                    id=summoned_by_{ID}#for filtering
                                                [/dummy]
                                            [/abilities]
                                        [/effect]
                                    [/object]
                                [/modifications]
                            [/unit]
                            [modify_unit]
                                [filter]
                                    id=$this_item.id
                                [/filter]
                                [set_variable]
                                    name=summon_cooldown_{ID}
                                    value=0
                                [/set_variable]
                            [/modify_unit]
                        [/else]
                    )}
                    {CLEAR_VARIABLE tmp_summons}
                    {CLEAR_VARIABLE tmp_summoncap}
                    {CLEAR_VARIABLE tmp_summontype}
                [/then]
            )}
        [/do]
    [/foreach]
    {CLEAR_VARIABLE {ID}}
[/event]
[+abilities]
#enddef

#define ABILITY_HOPLITE_BOMB EFFECTS
    [dummy]
        id=hoplite_bomb
        name= _ "bomb"
        description=_"At the start of its turn, this unit self-destructs, dealing damage to all adjacent units (except other bombs) with its first attack. The unit also explodes if killed."
    [/dummy] # wmlxgettext: [abilities]
    [dummy]
        id=spartan_bombfilter
    [/dummy]
    [dummy]
        id=spartan_bombfilter_avoid_ai#adding this as a seperate filter in case I add bombs that aren't important enough to avoid later (like a bomb that takes multiple turns to become ready to explode)
    [/dummy]
[/abilities]
[event]
    name=die
    id=hoplite_bomb_event
    first_time_only=no
    [filter]
        ability=hoplite_bomb
    [/filter]

    [hide_unit]
        x,y=$x1,$y1
    [/hide_unit]

    [spartan_harm_unit]
        [filter]
            [and]
                [filter_adjacent]
                    x,y=$x1,$y1
                [/filter_adjacent]
            [/and]
            [not]
                ability=spartan_bombfilter
                [or]
                    [filter_wml]
                        [status]
                            petrified=yes
                        [/status]
                    [/filter_wml]
                [/or]
            [/not]
        [/filter]
        [filter_second]
            id=$unit.id
        [/filter_second]
        amount=$unit.attack[0].damage
        damage_type=$unit.attack[0].type
        fire_event=yes
        kill=yes
        animate=yes
        delay=0
        experience=no
    [/spartan_harm_unit]
    #other effects for bombs, in case I add other bomb types
    {EFFECTS}
[/event]
[event]
    name=side turn
    id=hoplite_bomb_event2
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_bomb
            side=$side_number
        [/have_unit]
    [/filter_condition]
    {CHATMSG "clear bombs"}
    [kill]
        side=$side_number
        ability=hoplite_bomb
        animate=yes
        fire_event=yes
    [/kill]
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#TODO: make a player-friendly version of advanced bomb too

#define ABILITY_HOPLITE_ADVANCED_BOMB EFFECTS
    [dummy]
        id=hoplite_advanced_bomb
        name= _ "advanced bomb"
        description=_"At the start of its turn, this unit self-destructs, dealing damage to all adjacent enemies (unlike normal bomb, which damages allies too) with its first attack. The unit also explodes if killed."
    [/dummy] # wmlxgettext: [abilities]
    [dummy]
        id=spartan_bombfilter
    [/dummy]
    [dummy]
        id=spartan_bombfilter_avoid_ai#adding this as a seperate filter in case I add bombs that aren't important enough to avoid later (like a bomb that takes multiple turns to become ready to explode)
    [/dummy]
[/abilities]
[event]
    name=die
    id=hoplite_advanced_bomb_event
    first_time_only=no
    [filter]
        ability=hoplite_advanced_bomb
    [/filter]

    [hide_unit]
        x,y=$x1,$y1
    [/hide_unit]

    [spartan_harm_unit]
        [filter]
            [filter_side]
                [enemy_of]
                    side=$unit.side
                [/enemy_of]
            [/filter_side]
            [and]
                [filter_adjacent]
                    x,y=$x1,$y1
                [/filter_adjacent]
            [/and]
            [not]
                ability=spartan_bombfilter
                [or]
                    [filter_wml]
                        [status]
                            petrified=yes
                        [/status]
                    [/filter_wml]
                [/or]
            [/not]
        [/filter]
        [filter_second]
            id=$unit.id
        [/filter_second]
        amount=$unit.attack[0].damage
        damage_type=$unit.attack[0].type
        fire_event=yes
        kill=yes
        animate=yes
        delay=0
        experience=no
    [/spartan_harm_unit]
    #other effects for bombs, in case I add other bomb types
    {EFFECTS}
[/event]
[event]
    name=side turn
    id=hoplite_advanced_bomb_event2
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_advanced_bomb
            side=$side_number
        [/have_unit]
    [/filter_condition]
    {CHATMSG "clear advanced bombs"}
    [kill]
        side=$side_number
        ability=hoplite_advanced_bomb
        animate=yes
        fire_event=yes
    [/kill]
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_HOPLITE_BOSS_BOMB EFFECTS
    [dummy]
        id=hoplite_boss_bomb
        name= _ "boss bomb"
        description=_"At the start of its turn, this unit self-destructs, dealing damage to all adjacent enemies except bosses with its first attack. The unit also explodes if killed."
    [/dummy] # wmlxgettext: [abilities]
    [dummy]
        id=spartan_bombfilter
    [/dummy]
    [dummy]
        id=spartan_bombfilter_avoid_ai#adding this as a seperate filter in case I add bombs that aren't important enough to avoid later (like a bomb that takes multiple turns to become ready to explode)
    [/dummy]
[/abilities]
[event]
    name=die
    id=hoplite_boss_bomb_event
    first_time_only=no
    [filter]
        ability=hoplite_boss_bomb
    [/filter]

    [hide_unit]
        x,y=$x1,$y1
    [/hide_unit]

    [spartan_harm_unit]
        [filter]
            [and]
                [filter_adjacent]
                    x,y=$x1,$y1
                [/filter_adjacent]
            [/and]
            [not]
                ability=spartan_bombfilter
                [or]
                    [filter_wml]
                        [status]
                            petrified=yes
                        [/status]
                    [/filter_wml]
                [/or]
                [or]
                    ability=hoplite_boss_immunities
                [/or]
            [/not]
        [/filter]
        [filter_second]
            id=$unit.id
        [/filter_second]
        amount=$unit.attack[0].damage
        damage_type=$unit.attack[0].type
        fire_event=yes
        kill=yes
        animate=yes
        delay=0
        experience=no
    [/spartan_harm_unit]
    #other effects for bombs, in case I add other bomb types
    {EFFECTS}
[/event]
[event]
    name=side turn
    id=hoplite_boss_bomb_event2
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_boss_bomb
            side=$side_number
        [/have_unit]
    [/filter_condition]
    {CHATMSG "clear boss bombs"}
    [kill]
        side=$side_number
        ability=hoplite_boss_bomb
        animate=yes
        fire_event=yes
    [/kill]
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_HOPLITE_THROW_BOMB TYPE COOLDOWN RADIUS NAME DESCRIPTION
    [spartan_bombthrow]
        id=hoplite_throw_bomb{TYPE}
        name={NAME}
        description={DESCRIPTION}
        radius={RADIUS}
        cooldown={COOLDOWN}
    [/spartan_bombthrow] # wmlxgettext: [abilities]
    [dummy]
        id=hoplite_bombthrow_ai
    [/dummy]
[/abilities]
[event]
    name=turn refresh
    id=hoplite_throw_bomb{TYPE}
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_throw_bomb{TYPE}
            side=$side_number
        [/have_unit]
    [/filter_condition]
    {CHATMSG "bombthrow {TYPE}"}
    [store_unit]
        [filter]
            ability=hoplite_throw_bomb{TYPE}
            side=$side_number
            [not]
                [filter_wml]
                    [status]
                        petrified=yes
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        variable=hoplite_bombthrower
        kill=no
    [/store_unit]
    [foreach]
        array=hoplite_bombthrower
        index_var=i
        [do]
            {VARIABLE_OP this_item.variables.bombthrow_cooldown add 1}
            [unstore_unit]
                variable=this_item
                find_vacant=no
            [/unstore_unit]
            {IF_VAR this_item.variables.bombthrow_cooldown greater_than_equal_to $this_item.abilities.spartan_bombthrow.cooldown (
                [then]
                    {IF_VAR this_item.variation equals armed (
                        [and]
                            #check if potential targets exist
                            [have_unit]
                                [filter_side]
                                    [enemy_of]
                                        side=$side_number
                                    [/enemy_of]
                                [/filter_side]
                                [filter_location]
                                    [filter]
                                        id=$this_item.id
                                    [/filter]
                                    radius=$this_item.abilities.spartan_bombthrow.radius
                                    [filter_radius]
                                        terrain=!,Xu*^*,Xo*^*
                                    [/filter_radius]
                                [/filter_location]
                            [/have_unit]
                        [/and]
                        [then]
                            {VARIABLE this_item.variables.bombthrow_cooldown 0}
                            [unstore_unit]
                                variable=this_item
                                find_vacant=no
                            [/unstore_unit]
                            {SPARTAN_CHANGE_VARIATION_PRESERVING_HP_EXACT id=$this_item.id ()}
                            [store_unit]
                                [filter]
                                    [filter_side]
                                        [enemy_of]
                                            side=$side_number
                                        [/enemy_of]
                                    [/filter_side]
                                    [filter_location]
                                        [filter]
                                            id=$this_item.id
                                        [/filter]
                                        radius=$this_item.abilities.spartan_bombthrow.radius
                                        [filter_radius]
                                            terrain=!,Xu*^*,Xo*^*
                                        [/filter_radius]
                                    [/filter_location]
                                [/filter]
                                variable=hoplite_bombtarget
                                kill=no
                            [/store_unit]
                            {VARIABLE_OP bombtarget_index rand 0.."$($hoplite_bombtarget.length| - 1)"}
                            [move_unit_fake]
                                type={TYPE}
                                side=$hoplite_enemyside
                                x=$this_item.x,$hoplite_bombtarget[$bombtarget_index].x
                                y=$this_item.y,$hoplite_bombtarget[$bombtarget_index].y
                            [/move_unit_fake]

                            #intentionally set to enemy side, so that bombs spawned by allied bombers can be shield-bashed
                            {UNIT $hoplite_enemyside {TYPE} $hoplite_bombtarget[$bombtarget_index].x $hoplite_bombtarget[$bombtarget_index].y (
                                placement=map
                                passable=yes
                            )}
                            {CLEAR_VARIABLE bombtarget_index}
                        [/then]
                        [else]
                            {SPARTAN_CHANGE_VARIATION_PRESERVING_HP_EXACT id=$this_item.id armed}
                        [/else]
                    )}
                [/then]
            )}
            {CLEAR_VARIABLE hoplite_bombtarget}
        [/do]
    [/foreach]
    {CLEAR_VARIABLE hoplite_bombthrower}
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#version of throw bomb without relying on variation, cooldown is faster due to no "arming" state, and doesn't add bomb thrower AI
#define ABILITY_HOPLITE_THROW_BOMB_BOSS TYPE COOLDOWN RADIUS NAME DESCRIPTION
    [spartan_bombthrow]
        id=hoplite_throw_bomb_boss{TYPE}
        name={NAME}
        description={DESCRIPTION}
        radius={RADIUS}
        cooldown={COOLDOWN}
    [/spartan_bombthrow] # wmlxgettext: [abilities]
    #    [dummy]
    #        id=hoplite_bombthrow_ai
    #    [/dummy]
[/abilities]
[event]
    name=turn refresh
    id=hoplite_throw_bomb_boss{TYPE}
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_throw_bomb_boss{TYPE}
            side=$side_number
        [/have_unit]
    [/filter_condition]
    {CHATMSG "bombthrow boss {TYPE}"}
    [store_unit]
        [filter]
            ability=hoplite_throw_bomb_boss{TYPE}
            side=$side_number
            [not]
                [filter_wml]
                    [status]
                        petrified=yes
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        variable=hoplite_bombthrower
        kill=no
    [/store_unit]
    [foreach]
        array=hoplite_bombthrower
        index_var=i
        [do]
            {VARIABLE_OP this_item.variables.bombthrow_cooldown add 1}
            [unstore_unit]
                variable=this_item
                find_vacant=no
            [/unstore_unit]
            {IF_VAR this_item.variables.bombthrow_cooldown greater_than_equal_to $this_item.abilities.spartan_bombthrow.cooldown (
                [and]
                    #check if potential targets exist
                    [have_unit]
                        [filter_side]
                            [enemy_of]
                                side=$side_number
                            [/enemy_of]
                        [/filter_side]
                        [filter_location]
                            [filter]
                                id=$this_item.id
                            [/filter]
                            radius=$this_item.abilities.spartan_bombthrow.radius
                            [filter_radius]
                                terrain=!,{SPARTAN_WALL_TERRAIN}
                            [/filter_radius]
                        [/filter_location]
                    [/have_unit]
                [/and]
                [then]
                    {VARIABLE this_item.variables.bombthrow_cooldown 0}
                    [unstore_unit]
                        variable=this_item
                        find_vacant=no
                    [/unstore_unit]
                    [store_unit]
                        [filter]
                            [filter_side]
                                [enemy_of]
                                    side=$side_number
                                [/enemy_of]
                            [/filter_side]
                            [filter_location]
                                [filter]
                                    id=$this_item.id
                                [/filter]
                                radius=$this_item.abilities.spartan_bombthrow.radius
                                [filter_radius]
                                    terrain=!,{SPARTAN_WALL_TERRAIN}
                                [/filter_radius]
                            [/filter_location]
                        [/filter]
                        variable=hoplite_bombtarget
                        kill=no
                    [/store_unit]
                    {VARIABLE_OP bombtarget_index rand 0.."$($hoplite_bombtarget.length| - 1)"}
                    [move_unit_fake]
                        type={TYPE}
                        side=$hoplite_enemyside
                        x=$this_item.x,$hoplite_bombtarget[$bombtarget_index].x
                        y=$this_item.y,$hoplite_bombtarget[$bombtarget_index].y
                    [/move_unit_fake]

                    #intentionally set to enemy side, so that bombs spawned by allied bombers can be shield-bashed
                    {UNIT $hoplite_enemyside {TYPE} $hoplite_bombtarget[$bombtarget_index].x $hoplite_bombtarget[$bombtarget_index].y (
                        placement=map
                        passable=yes
                    )}
                    {CLEAR_VARIABLE bombtarget_index}
                [/then]
            )}
            {CLEAR_VARIABLE hoplite_bombtarget}
        [/do]
    [/foreach]
    {CLEAR_VARIABLE hoplite_bombthrower}
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#define SPARTAN_TELEPORT_CODE VARIABLE RADIUS
    [tunnel]
        id=hoplite_teleport{RADIUS}
        [source]
            terrain=!,{SPARTAN_WALL_TERRAIN}
        [/source]
        [target]
            terrain=!,{SPARTAN_WALL_TERRAIN}
            [not]
                [filter]
                    [filter_side]
                        [enemy_of]
                            side={VARIABLE}.side
                        [/enemy_of]
                    [/filter_side]
                [/filter]
                radius=2
            [/not]
            [and]
                [filter]
                    id={VARIABLE}.id
                [/filter]
                radius={RADIUS}
            [/and]
        [/target]
        [redraw]
        [/redraw]
        [filter]
            ability=hoplite_teleport{RADIUS}
        [/filter]
    [/tunnel]
#enddef

#define ABILITY_HOPLITE_TELEPORT RADIUS
    [teleport]
        id=hoplite_teleport{RADIUS}
        name= _ "teleport"+" {RADIUS}"
        female_name= _ "teleport"+" {RADIUS}"
        description= _ "this unit can teleport to any tile in a"+" {RADIUS}"+_"-tile radius of itself except those in a 2-tile radius of the enemy units."
        {SPARTAN_TELEPORT_CODE $teleport_unit {RADIUS}}
    [/teleport]
#enddef

#very hacky workaround, the different variable subsitution is needed to make Elizabeth IV upgrade work properly

#define ABILITY_HOPLITE_TELEPORT_FOR_EFFECT RADIUS
    [teleport]
        id=hoplite_teleport{RADIUS}
        name= _ "teleport"+" {RADIUS}"
        female_name= _ "teleport"+" {RADIUS}"
        description= _ "this unit can teleport to any tile in a"+" {RADIUS}"+_"-tile radius of itself except those in a 2-tile radius of the enemy units."
        {SPARTAN_TELEPORT_CODE $|teleport_unit {RADIUS}}
    [/teleport]
#enddef

#for shielders/defenders, to force them to use their pushing 0-1 attack
#define SPARTAN_AI_USE_FIRST_ATTACK
    [dummy]
        id=spartan_ai_use_first_attack
    [/dummy]
#enddef

#workaround for scorpion, and possibly some other melee units
#define SPARTAN_AI_FORCE_ATTACK_WITH_BEST
    [dummy]
        id=spartan_ai_force_attack_with_best
    [/dummy]
#enddef

#used for giant mudcrawlers, and possibly for myrmidon unit later on

# wmllint: unbalanced-on
#define ABILITY_SPARTAN_SPAWN_UNITS_ON_DEATH NAME DESCRIPTION TYPE AMOUNT
    [spartan_split]
        id=spartan_split
        name={NAME}
        description={DESCRIPTION}
        type={TYPE}
        amount={AMOUNT}
    [/spartan_split]
[/abilities]
[event]
    id=spartan_split_ability
    name=die
    first_time_only=no

    [filter]
        ability=spartan_split
    [/filter]

    {REPEAT $unit.abilities.spartan_split.amount (
        [unit]
            type=$unit.abilities.spartan_split.type
            side=$unit.side
            x,y=$unit.x,$unit.y
            moves=0
            attacks_left=0
            animate=yes
            placement=map
            passable=yes
        [/unit]
    )}
[/event]
[+abilities]
#enddef
# wmllint: unbalanced-off

#define ABILITY_HOPLITE_LEAP_NONPLAYER COOLDOWN
    [hoplite_nonplayer_leap]
        id=hoplite_nonplayer_leap
        name=_"leap"+" ({COOLDOWN} "+_"turns)"
        description=_"This unit can leap in a 2-tile radius every"+" {COOLDOWN} "+_"turns. If a unit is a bout to leap, the increased movement distance is visible on your turn too."
        cooldown={COOLDOWN}
    [/hoplite_nonplayer_leap]
#enddef

#define HOPLITE_LEAP_NONPLAYER_EVENTS
    [event]
        #in order to make leap telegraphed to players
        name=side 1 turn refresh
        first_time_only=no
        id=hoplite_nonplayer_leap_event
        first_time_only=no
        [filter_condition]
            [have_unit]
                ability=hoplite_nonplayer_leap
                #                side=$side_number
            [/have_unit]
        [/filter_condition]
        {CHATMSG "nonplayer leap event"}

        [store_unit]
            [filter]
                ability=hoplite_nonplayer_leap
            [/filter]
            variable=nonplayer_leapers
            kill=no
        [/store_unit]
        [foreach]
            array=nonplayer_leapers
            index_var=i
            [do]
                {IF_VAR this_item.variables.leap_cooldown greater_than_equal_to $this_item.abilities.hoplite_nonplayer_leap.cooldown (
                    [then]
                        [object]
                            silent=yes
                            duration=turn end
                            [filter]
                                id=$this_item.id
                            [/filter]
                            [effect]
                                apply_to=new_ability
                                [abilities]
                                    {ABILITY_LEAPING2}
                                [/abilities]
                            [/effect]
                            [effect]
                                apply_to=new_animation
                                [animation]
                                    apply_to=pre_teleport
                                    [frame]
                                        duration=300
                                        offset=0.0~1.0:300
                                        y=0~-25:300
                                        sound={SOUND_LIST:MISS}
                                    [/frame]
                                [/animation]
                                [animation]
                                    apply_to=post_teleport
                                    [frame]
                                        duration=300
                                        offset=-1.0~0.0:300
                                        y=-25~0:300
                                    [/frame]
                                [/animation]
                            [/effect]
                        [/object]
                        [modify_unit]
                            [filter]
                                id=$this_item.id
                            [/filter]
                            [set_variable]
                                name=leap_cooldown
                                value=0
                            [/set_variable]
                        [/modify_unit]
                        [floating_text]
                            x=$this_item.x|
                            y=$this_item.y|
                            text=_ "about to leap"
                        [/floating_text]
                    [/then]
                )}
                #important: this MUST be after the variable check, since the variable check only cares about the value at the time of the unit being stored
                [modify_unit]
                    [filter]
                        id=$this_item.id
                    [/filter]
                    [set_variable]
                        name=leap_cooldown
                        #                    sub=1
                        add=1#cooldown now counts up instead of down
                    [/set_variable]
                [/modify_unit]
            [/do]
        [/foreach]
        {CLEAR_VARIABLE nonplayer_leapers}
    [/event]
    [event]
        name=unit placed,spartan_apply_leap_and_sluggish_manually
        id=spartan_leap_start
        first_time_only=no
        [filter]
            ability=hoplite_nonplayer_leap
            [not]
                ability=spartan_applied_leap_start
            [/not]
        [/filter]
        [modify_unit]
            [filter]
                id=$unit.id
            [/filter]
            [set_variable]
                name=leap_cooldown
                add=2
            [/set_variable]
        [/modify_unit]
        [object]
            silent=yes
            duration=forever
            [filter]
                id=$unit.id
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    [dummy]
                        id=spartan_applied_leap_start
                    [/dummy]
                [/abilities]
            [/effect]
        [/object]
    [/event]
#enddef

#define ABILITY_HOPLITE_SLUGGISH COOLDOWN
    [hoplite_sluggish]
        id=hoplite_sluggish
        name=_"sluggish"+" ({COOLDOWN} "+_"turns)"
        description=_"This unit can only move/attack once every"+" {COOLDOWN} "+_"turns, otherwise it has 0 max moves/attacks. If a unit is a bout to move, the increased movement distance is visible on your turn too."
        cooldown={COOLDOWN}
    [/hoplite_sluggish]
#enddef

#define HOPLITE_SLUGGISH_EVENTS
    [event]
        #in order to make leap telegraphed to players
        name=side 1 turn refresh
        first_time_only=no
        id=hoplite_sluggish_event
        first_time_only=no
        [filter_condition]
            [have_unit]
                ability=hoplite_sluggish
                #                side=$side_number
            [/have_unit]
        [/filter_condition]
        {CHATMSG "sluggish event"}

        [store_unit]
            [filter]
                ability=hoplite_sluggish
            [/filter]
            variable=sluggish_enemies
            kill=no
        [/store_unit]
        [foreach]
            array=sluggish_enemies
            index_var=i
            [do]
                {IF_VAR this_item.variables.sluggish_cooldown greater_than_equal_to $this_item.abilities.hoplite_sluggish.cooldown (
                    [then]
                        [floating_text]
                            x=$this_item.x|
                            y=$this_item.y|
                            text=_ "about to move"
                        [/floating_text]
                        [modify_unit]
                            [filter]
                                id=$this_item.id
                            [/filter]
                            [set_variable]
                                name=sluggish_cooldown
                                value=0
                            [/set_variable]
                        [/modify_unit]
                    [/then]
                    [else]
                        [object]
                            silent=yes
                            duration=turn end
                            [filter]
                                id=$this_item.id
                            [/filter]
                            [effect]
                                apply_to=attack
                                [set_specials]
                                    mode=append
                                    [disable]
                                        id=spartan_sluggish_disableattack
                                    [/disable]
                                [/set_specials]
                            [/effect]
                            [effect]
                                apply_to=movement
                                set=0
                            [/effect]
                        [/object]
                    [/else]
                )}
                #important: this MUST be after the variable check, since the variable check only cares about the value at the time of the unit being stored
                [modify_unit]
                    [filter]
                        id=$this_item.id
                    [/filter]
                    [set_variable]
                        name=sluggish_cooldown
                        #                    sub=1
                        add=1#cooldown now counts up instead of down
                    [/set_variable]
                [/modify_unit]
            [/do]
        [/foreach]
        {CLEAR_VARIABLE sluggish_enemies}
    [/event]
    [event]
        name=unit placed,spartan_apply_leap_and_sluggish_manually
        id=spartan_sluggish_start
        first_time_only=no
        [filter]
            ability=hoplite_sluggish
            [not]
                ability=spartan_applied_sluggish_start
            [/not]
        [/filter]
        [object]
            silent=yes
            duration=turn end
            [filter]
                id=$unit.id
            [/filter]
            [effect]
                apply_to=attack
                [set_specials]
                    mode=append
                    [disable]
                        id=spartan_sluggish_disableattack
                    [/disable]
                [/set_specials]
            [/effect]
            [effect]
                apply_to=movement
                set=0
            [/effect]
        [/object]
        [object]
            silent=yes
            duration=forever
            [filter]
                id=$unit.id
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    [dummy]
                        id=spartan_applied_sluggish_start
                    [/dummy]
                [/abilities]
            [/effect]
        [/object]
        [modify_unit]
            [filter]
                id=$unit.id
            [/filter]
            [set_variable]
                name=sluggish_cooldown
                add=2
            [/set_variable]
        [/modify_unit]
    [/event]
#enddef

#for allies who you can't give orders to, nor swap places with. for now just intended for Mysterious Merchant, and possibly other stationary npcs later

#define SPARTAN_ALLY_IMMOVABLE
    [dummy]
        id=spartan_ally_immovable
    [/dummy]
#enddef

# wmllint: unbalanced-on
#extra code is used for dialog/summons/etc.
#can be chained (ability on the transformed type too) to make units with more than 2 phases
#define ABILITY_HOPLITE_BOSS_CHANGE_PHASE_UNIT_TYPE ID NEW_UNIT_TYPE HP_MULT EXTRA_CODE
    [dummy]
        id=hoplite_phase_change{ID}
        name= _ "phase change"
        description=_"If this boss loses enough hp, it transforms into a different, usually more powerful version."
    [/dummy] # wmlxgettext: [abilities]
[/abilities]
[event]
    name=attack end,side turn
    id=hoplite_phase_change_event{ID}
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_phase_change{ID}
        [/have_unit]
    [/filter_condition]
    [store_unit]
        [filter]
            ability=hoplite_phase_change{ID}
        [/filter]
        kill=no
        variable=spartan_phasechange_bosses{ID}
    [/store_unit]

    [foreach]
        array=spartan_phasechange_bosses{ID}
        index_var=a
        [do]
            [if]
                {VARIABLE_CONDITIONAL this_item.hitpoints less_than_equal_to "$($this_item.max_hitpoints * {HP_MULT})"}
                [then]
                    {TRANSFORM_UNIT id=$this_item.id {NEW_UNIT_TYPE}}
                    {EXTRA_CODE}
                [/then]
            [/if]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE spartan_phasechange_bosses{ID}}
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#define ABILITY_HOPLITE_PATRON_UNIT
    #used for the "enthrall a patreon unit" achievement
    [dummy]
        id=hoplite_patron_unit
    [/dummy]
#enddef

#used for Deployed Shield

# wmllint: unbalanced-on
#define ABILITY_HOPLITE_TEMPORARY
    [dummy]
        id=hoplite_temporary
        name= _ "temporary"
        description=_"At the start of the next turn, this unit disappears."
    [/dummy] # wmlxgettext: [abilities]
[/abilities]
[event]
    name=new turn
    id=hoplite_temporary_event
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_temporary
        [/have_unit]
    [/filter_condition]
    {CHATMSG "clear temporary units"}
    [kill]
        ability=hoplite_temporary
        animate=yes
        fire_event=yes
    [/kill]
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#for spearless variant

#define WEAPON_SPECIAL_HOPLITE_SPEAR_INACTIVE
    [disable]
        id=hoplite_spearinactive
        name=_"unavailable"
        description=_"The spear can't be used until you pick it up"
    [/disable]
#enddef


#version of cleave for enemies/allies instead of the player

#define WEAPON_SPECIAL_HOPLITE_CLEAVE
    [dummy]
        id=hoplite_cleave
        name=_"cleave"
        description=_"When hitting an enemy with this attack, deal 50% of the attack's base damage to enemies that are adjacent to both you and the target."
    [/dummy]
#enddef

#define HOPLITE_CLEAVE_EVENT
    [event]
        name=attacker hits
        id=spartan_generic_cleave
        first_time_only=no
        [filter_attack]
            special_id=hoplite_cleave
        [/filter_attack]

        [store_unit]
            [filter]
                [filter_side]
                    [enemy_of]
                        side=$unit.side
                    [/enemy_of]
                [/filter_side]
                [filter_adjacent]
                    x,y=$x2,$y2
                [/filter_adjacent]
                [filter_adjacent]
                    x,y=$x1,$y1
                [/filter_adjacent]
                [not]
                    [filter_wml]
                        [status]
                            petrified=yes
                        [/status]
                    [/filter_wml]
                    [or]
                        id=$second_unit.id
                    [/or]
                [/not]
            [/filter]
            variable=bystander
        [/store_unit]

        {VARIABLE areadmg $weapon.damage}
        {VARIABLE_OP areadmg multiply 0.5}

        [if]
            {VARIABLE_CONDITIONAL unit.status.slowed boolean_equals yes}
            [then]
                {VARIABLE_OP areadmg divide 2}
                {VARIABLE_OP areadmg round floor}
            [/then]
        [/if]

        [foreach]
            array=bystander
            [do]
                [spartan_harm_unit]
                    [filter]
                        id=$this_item.id
                    [/filter]
                    [filter_second]
                        id=$unit.id
                    [/filter_second]
                    amount=$areadmg
                    damage_type=$weapon.type
                    fire_event=yes
                    animate=defender
                    delay=0
                    experience=yes
                [/spartan_harm_unit]
            [/do]
        [/foreach]
        {CLEAR_VARIABLE bystander}
    [/event]
#enddef

#define ABILITY_HOPLITE_PATRON_AMAKRI_MEND_UNDEAD
    [dummy]
        id=hoplite_amakri_mend_undead
        name=_"mend undead"
        description=_"Each turn, this unit heals nearby allied undead in a radius:

1-tile radius: 5 HP per turn
2-tile radius: 4 HP per turn
3-tile radius: 3 HP per turn
4-tile radius: 2 HP per turn

(Cannot heal through walls)"
    [/dummy]
[/abilities]
[event]
    name=turn refresh
    first_time_only=no
    id=hoplite_mend_undead_event
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=hoplite_amakri_mend_undead
            side=$side_number
        [/have_unit]
    [/filter_condition]

    [store_unit]
        [filter]
            ability=hoplite_amakri_mend_undead
            side=$side_number
        [/filter]
        variable=undead_menders
    [/store_unit]
    [foreach]
        array=undead_menders
        index_var=i
        [do]
            [heal_unit]
                [filter]
                    trait=undead
                    [filter_side]
                        [allied_with]
                            side=$side_number
                        [/allied_with]
                    [/filter_side]
                    [filter_location]
                        # Exclude the units in the middle
                        [not]
                            x,y=$this_item.x,$this_item.y
                        [/not]
                        # Include the remaining units within the radius
                        [and]
                            x,y=$this_item.x,$this_item.y
                            radius=1
                            # The healing cannot go through walls.
                            [filter_radius]
                                [not]
                                    terrain={SPARTAN_WALL_TERRAIN}
                                [/not]
                            [/filter_radius]
                        [/and]
                    [/filter_location]
                [/filter]
                amount=5
                animate=yes
                restore_statuses=no
            [/heal_unit]
            [heal_unit]
                [filter]
                    trait=undead
                    [filter_side]
                        [allied_with]
                            side=$side_number
                        [/allied_with]
                    [/filter_side]
                    [filter_location]
                        # Exclude the units in the middle
                        [not]
                            x,y=$this_item.x,$this_item.y
                            radius=1
                        [/not]
                        # Include the remaining units within the radius
                        [and]
                            x,y=$this_item.x,$this_item.y
                            radius=2
                            # The healing cannot go through walls.
                            [filter_radius]
                                [not]
                                    terrain={SPARTAN_WALL_TERRAIN}
                                [/not]
                            [/filter_radius]
                        [/and]
                    [/filter_location]
                [/filter]
                amount=4
                animate=yes
                restore_statuses=no
            [/heal_unit]
            [heal_unit]
                [filter]
                    trait=undead
                    [filter_side]
                        [allied_with]
                            side=$side_number
                        [/allied_with]
                    [/filter_side]
                    [filter_location]
                        # Exclude the units in the middle
                        [not]
                            x,y=$this_item.x,$this_item.y
                            radius=2
                        [/not]
                        # Include the remaining units within the radius
                        [and]
                            x,y=$this_item.x,$this_item.y
                            radius=3
                            # The healing cannot go through walls.
                            [filter_radius]
                                [not]
                                    terrain={SPARTAN_WALL_TERRAIN}
                                [/not]
                            [/filter_radius]
                        [/and]
                    [/filter_location]
                [/filter]
                amount=3
                animate=yes
                restore_statuses=no
            [/heal_unit]
            [heal_unit]
                [filter]
                    trait=undead
                    [filter_side]
                        [allied_with]
                            side=$side_number
                        [/allied_with]
                    [/filter_side]
                    [filter_location]
                        # Exclude the units in the middle
                        [not]
                            x,y=$this_item.x,$this_item.y
                            radius=3
                        [/not]
                        # Include the remaining units within the radius
                        [and]
                            x,y=$this_item.x,$this_item.y
                            radius=4
                            # The healing cannot go through walls.
                            [filter_radius]
                                [not]
                                    terrain={SPARTAN_WALL_TERRAIN}
                                [/not]
                            [/filter_radius]
                        [/and]
                    [/filter_location]
                [/filter]
                amount=2
                animate=yes
                restore_statuses=no
            [/heal_unit]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE undead_menders}
[/event]
[+abilities]
#enddef

#define ABILITY_SPARTAN_ENEMY_NOT_IMPORTANT_TO_WIN_AND_DOES_NOT_BLOCK_INFINITE_MOVES
    #dummy ability to make some enemies not count for the "are there any enemies" checks in automove/infinite moves code
    #for example, gates
    [dummy]
        id=hoplite_unimportant_enemy
    [/dummy]
#enddef

#define ABILITY_SPARTAN_HEALS VALUE
        [heals]
            value={VALUE}
            id=healing
            affect_allies=yes
            name= _ "heals"+" {VALUE}"
            female_name= _ "female^heals"+" {VALUE}"
            description=  _ "Allows the unit to heal adjacent allied units at the beginning of our turn.

A unit cared for by this healer may heal up to"+" {VALUE} "+_" HP per turn, or stop poison from taking effect for that turn.
This ability will not cure an affected unit of poison, however, only delay its effect."
            affect_self=no
            poison=slowed
            [affect_adjacent]
            [/affect_adjacent]
        [/heals]
    #for the "approach healer" AI
    [dummy]
        id=spartan_healer_filter
    [/dummy]      
#enddef

#define ABILITY_SPARTAN_HEALER_AI
    #dummy ability to make healers move towards wounded enemies
    [dummy]
        id=spartan_healer_ai
    [/dummy]
#enddef

#define ABILITY_SPARTAN_HEALER_RETREAT_AI
    #dummy ability to make healers retreat when near enemies, similarly to ranged units (but not as cowardly as cowardly units)
    [dummy]
        id=spartan_healer_retreat_ai
    [/dummy]
#enddef

#define ABILITY_SPARTAN_BOSS_LENIENT_RANGED_AI
    ##for archmage/grand seer/other teleporting ranged bosses, to be more lenient towards players and not retreat too soon
    [dummy]
        id=spartan_boss_lenient_ranged_ai
    [/dummy]
#enddef

#define SPARTAN_AMBUSH_LANTERN_FILTER SELF_SIDES
    side={SELF_SIDES}
    [filter_location]
        [not]
            [filter]
                [filter_side]
                    [enemy_of]
                        side={SELF_SIDES}
                    [/enemy_of]
                [/filter_side]
                ability=hoplite_lantern
            [/filter]
            radius=2
            [filter_radius]
                [not]
                    terrain=Xu*^*,Xo*^*
                [/not]
            [/filter_radius]
        [/not]
        [not]
            [filter]
                [filter_side]
                    [enemy_of]
                        side={SELF_SIDES}
                    [/enemy_of]
                [/filter_side]
                ability=hoplite_lantern2
            [/filter]
            radius=3
            [filter_radius]
                [not]
                    terrain=Xu*^*,Xo*^*
                [/not]
            [/filter_radius]
        [/not]
    [/filter_location]
#enddef

#define ABILITY_SPARTAN_AMBUSH
    # Canned definition of the Ambush ability to be included in an
    # [abilities] clause.
    [hides]
        id=spartan_ambush
        name= _ "ambush"
        female_name= _ "female^ambush"
        description= _ "This unit can hide in forest, and remain undetected by its enemies.

Enemy units cannot see this unit while it is in forest, except if they have units next to it. Any enemy unit that first discovers this unit immediately loses all its remaining movement."
        special_note={INTERNAL:SPECIAL_NOTES_AMBUSH}
        affect_self=yes
        # ^Qhh* and ^Qhu* are the bluff and glutch terrains, like are already overlay the variant forest must be include in filter with 'traditionnals' forests terrains
        [filter]
            [filter_location]
                terrain=*^F*,*^Qhhf,*^Qhuf
            [/filter_location]
            [and]
                {SPARTAN_AMBUSH_LANTERN_FILTER $hoplite_enemyside}
                [or]
                    {SPARTAN_AMBUSH_LANTERN_FILTER $hoplite_playerside,$hoplite_allyside}
                [/or]
            [/and]
        [/filter]
    [/hides]
#enddef

#event is in the 

#define WEAPON_SPECIAL_SPARTAN_BURN NUMBER
    [burn]
        id=spartan_burn
        name=_"burn"+" {NUMBER}"
        description=_"On hit, this attack applies burn to the enemy. The enemy takes "+{NUMBER}+_" fire damage every turn. Applying a stronger version of burn replaces the weaker one."
        burn_number={NUMBER}
    [/burn]
#enddef

#define WEAPON_SPECIAL_SPARTAN_HOLY DAMAGE
    [damage]
        id=spartan_holy
        name= _ "holy "+{DAMAGE}
        description=_ "This attack deals +"+{DAMAGE}+_" damage against undead and demons, or enemies with the 'unholy' trait."
        add={DAMAGE}
        [filter_opponent]
            trait=undead
            [or]
                race=spartan_demon
            [/or]
            [or]
                #used for the Merchant since I don't want the whole unknown race to be affected by it for now
                ability=spartan_affected_by_holy_damage
            [/or]
            [or]
                trait=unholy
            [/or]
        [/filter_opponent]
    [/damage]
#enddef

#define WEAPON_SPECIAL_SPARTAN_SWEEPING_SLOW
    [dummy]
        id=spartan_sweepingslow
        name=_"sweeping slow"
        description=_"This attack can slow several enemies at once (slows enemies that are adjacent to both you and the target)"
    [/dummy]
#enddef

#define ABILITY_SPARTAN_COMPANION
    [dummy]
        id=hoplite_companion
        name= _ "companion"
        description=_ "This unit carries over when descending a depth, and recovers 50% of max hitpoints while doing so. He/she also doesn't permanently die after reaching 0 hp, instead fleeing and returning after 3 depths."
    [/dummy]
#enddef

#define WEAPON_SPECIAL_SPARTAN_COMBO NUMBER
    [combo]
        id=spartan_combo
        name= _ "combo"+" {NUMBER}"
        description=_"If an enemy is killed with this attack, the attacker can attack again with any weapon. This effect can trigger "+" {NUMBER} "+"times per turn."
        combo_limit={NUMBER}
    [/combo]
#enddef

#define SPARTAN_COMBO_EVENTS
    [event]
        name=die
        id=spartan_combo_event
        first_time_only=no
        [filter_second_attack]
            special_id=spartan_combo
        [/filter_second_attack]
        #only triggers on offense
        [filter_condition]
            {VARIABLE_CONDITIONAL second_unit.side equals $side_number}
        [/filter_condition]

        [if]
            {VARIABLE_CONDITIONAL second_unit.abilities.spartan_combo_tracker.times greater_than_equal_to $second_weapon.specials.combo.combo_limit}
            [else]
                {VARIABLE tmp_combo_counter 0}
                {VARIABLE_OP tmp_combo_counter add $second_unit.abilities.spartan_combo_tracker.times}
                {VARIABLE_OP tmp_combo_counter add 1}
                [object]
                    silent=yes
                    duration=turn end
                    [filter]
                        x,y=$x2,$y2
                    [/filter]
                    [effect]
                        apply_to=remove_ability
                        [abilities]
                            [spartan_combo_tracker]
                                id=hoplite_combo_triggered
                            [/spartan_combo_tracker]
                        [/abilities]
                    [/effect]
                    [effect]
                        apply_to=new_ability
                        [abilities]
                            [spartan_combo_tracker]
                                id=hoplite_combo_triggered
                                times=$tmp_combo_counter
                            [/spartan_combo_tracker]
                        [/abilities]
                    [/effect]
                [/object]
                {MODIFY_UNIT id=$second_unit.id attacks_left "$($second_unit.attacks_left + 1)"}
                [floating_text]
                    x,y=$x2,$y2
                    text=_"combo"
                [/floating_text]
            [/else]
        [/if]
        {CLEAR_VARIABLE tmp_combo_counter}
    [/event]
#enddef

#define SPARTAN_REGENERATES_LESSER VALUE
    [regenerate]
        value={VALUE}
        id=spartan_regenerates_lesser
        name= _ "regenerates"+" +{VALUE}"
        female_name= _ "female^regenerates"+" +{VALUE}"
        description= _ "The unit will heal itself"+ " {VALUE} " + _"HP per turn, or stop poison from taking effect for that turn."
        affect_self=yes
        poison=slowed
    [/regenerate]
#enddef

#define ILLUSION_WRAITHS_EVENT_PART ID DIR
    [store_unit]
        [filter]
            type=$this_item.abilities.hoplite_illusion_{ID}.wraith_type
        [/filter]
        variable=reaperclones
        kill=no
    [/store_unit]
    [store_locations]
        [not]
            terrain={SPARTAN_WALL_TERRAIN}
        [/not]

        [filter_adjacent_location]
            x,y=$illusion_targetloc.x,$illusion_targetloc.y
            adjacent={DIR}
        [/filter_adjacent_location]

        variable=grimreaper{DIR}1
    [/store_locations]
    [store_locations]
        [not]
            [filter]
            [/filter]
            [or]
                terrain={SPARTAN_WALL_TERRAIN}
            [/or]
        [/not]

        [filter_adjacent_location]
            x,y=$grimreaper{DIR}1.x,$grimreaper{DIR}1.y
            adjacent={DIR}
        [/filter_adjacent_location]

        variable=grimreaper{DIR}2
    [/store_locations]
    {UNIT $this_item.side $this_item.abilities.hoplite_illusion_{ID}.wraith_type $grimreaper{DIR}2.x $grimreaper{DIR}2.y (
        [modifications]
            [object]
                silent=yes
                [effect]
                    apply_to=new_ability
                    [abilities]
                        [dummy]
                            id=spartan_illusion_wraith_{ID}
                        [/dummy]
                        [dummy]
                            id=spartan_illusion_wraith_owned_by_$this_item.id
                        [/dummy]
                    [/abilities]
                [/effect]
            [/object]
        [/modifications]
    )}

    {CLEAR_VARIABLE grimreaper{DIR}1}
    {CLEAR_VARIABLE grimreaper{DIR}2}
    {CLEAR_VARIABLE reaperclones}
    [redraw]
    [/redraw]
#enddef

#define SPARTAN_ILLUSION_CHOOSE_ONE_ILLUSION_TO_BE_REAL UNIT_VAR ID
    [store_unit]
        [filter]
            type=${UNIT_VAR}.abilities.hoplite_illusion_{ID}.wraith_type
            ability=spartan_illusion_wraith_owned_by_${UNIT_VAR}.id
        [/filter]
        variable=real_illusion_{ID}
        kill=no
    [/store_unit]
    {RANDOM 0.."$($real_illusion_{ID}.length - 1)"}

    {VARIABLE real_illusion_{ID}[$random].id real_${UNIT_VAR}.id|}
    {VARIABLE real_illusion_{ID}[$random].variables.illusion_stored_id ${UNIT_VAR}.id|}
    [unstore_unit]
        variable=real_illusion_{ID}[$random]
    [/unstore_unit]
    [if]
        [have_unit]
            id=real_$t{UNIT_VAR}.id|
        [/have_unit]
        [else]
            {VARIABLE real_illusion_{ID}[0].id real_${UNIT_VAR}.id|}
            {VARIABLE real_illusion_{ID}[0].variables.illusion_stored_id ${UNIT_VAR}.id|}
            [unstore_unit]
                variable=real_illusion_{ID}[0]
            [/unstore_unit]
        [/else]
    [/if]
    {CLEAR_VARIABLE real_illusion_{ID}}
#enddef

#define SPARTAN_ILLUSION_ANTI_SOFTLOCK ID
        #failsafe in case all reaper shadows disappear without triggering the unstore event, force unstore the reaper

        [foreach]
            array=illusion_stored_{ID}
            index_var=a
            [do]
                [if]
                    [have_unit]
                        id=real_$this_item.id
                    [/have_unit]
                    [else]
                        #if the main illusion is gone but there are backups left, choose a new illusion to be the real one:
                        [if]
                            [have_unit]
                                ability=spartan_illusion_wraith_owned_by_$this_item.id
                            [/have_unit]
                            [then]
                                {SPARTAN_ILLUSION_CHOOSE_ONE_ILLUSION_TO_BE_REAL this_item {ID}}
                            [/then]
                            [else]
                                #if there are no valid wraiths left, unstore the unit directly
                                [store_map_dimensions]
                                [/store_map_dimensions]
                                #[chat]
                                #    message=_"id $this_item.id|"
                                #[/chat]
                                [unstore_unit]
                                    variable=this_item
                                    x,y="$($map_size.width / 2)","$($map_size.height / 2)"
                                    find_vacant=yes
                                [/unstore_unit]
                                #no longern needed
                                #[unhide_unit]
                                #    id=$this_item.id
                                #[/unhide_unit]
                                [modify_unit]
                                    [filter]
                                        id=$this_item.id
                                    [/filter]
                                    [status]
                                        slowed=yes
                                    [/status]
                                [/modify_unit]
                            [/else]
                        [/if]
                        #{VARIABLE tmp_illusion_unstore_index $a}
                        #{VARIABLE tmp_illusion_unstore_found_valid_unit yes}
                        #[break]
                        #[/break]
                    [/else]
                [/if]
            [/do]
        [/foreach]

        #cleaning up unstored units from the stored variable in a while loop, since clearing variables directly inside [foreach] is not supported

        {VARIABLE tmp_spartan_illusion_clear_index 0}
        [while]
            [variable]
            name=tmp_spartan_illusion_clear_index
            less_than=$illusion_stored_{ID}.length
            [/variable]
            [do]
                [if]
                [have_unit]
                    id=$illusion_stored_{ID}[$tmp_spartan_illusion_clear_index].id
                [/have_unit]
                [then]
                    {CLEAR_VARIABLE illusion_stored_{ID}[$tmp_spartan_illusion_clear_index]}
                    #offset the index to compensate the variable being cleared
                    {VARIABLE_OP tmp_spartan_illusion_clear_index sub 1}
                [/then]
                [/if]
                {VARIABLE_OP tmp_spartan_illusion_clear_index add 1}
            [/do]
        [/while]
        {CLEAR_VARIABLE tmp_spartan_illusion_clear_index}
#enddef

#define SPARTAN_ABILITY_ILLUSIONS ID NAME DESCRIPTION WRAITH_TYPE COOLDOWN
    #[hoplite_summon_{ID}] is used to make it possible to have multiple illusion abilities on one unit just in case, like what I did with summon
    [hoplite_illusion_{ID}]
        id=hoplite_illusion_{ID}
        name={NAME}
        description={DESCRIPTION}
        wraith_type={WRAITH_TYPE}
        #NOTE: now cooldown is not counted while the unit is unstored, not while the wraiths are on the map!
        cooldown={COOLDOWN}
    [/hoplite_illusion_{ID}]
    [dummy]
        id=illusion_ability_filter
    [/dummy]
[/abilities]

    [event]
        name=side turn end
        id=spartan_hoplite_illusion_{ID}
        first_time_only=no

        [filter_condition]
            [have_unit]
                ability=hoplite_illusion_{ID}
                side=$side_number
            [/have_unit]
            [or]
                {VARIABLE_CONDITIONAL illusion_stored_{ID}.length greater_than 0}
            [/or]
        [/filter_condition]

        {SPARTAN_ILLUSION_ANTI_SOFTLOCK {ID}}

        [store_unit]
            [filter]
                ability=hoplite_illusion_{ID}
                side=$side_number
                [not]
                    [filter_wml]
                        [status]
                            slowed=yes
                        [/status]
                    [/filter_wml]
                [/not]
            [/filter]
            variable={ID}
        [/store_unit]
        [foreach]
            array={ID}
            index_var=i
            [do]
            [modify_unit]
                [filter]
                    id=$this_item.id
                [/filter]
                [set_variable]
                    name=illusion_cooldown_{ID}
                    sub=1
                [/set_variable]
            [/modify_unit]
            [if]
            {VARIABLE_CONDITIONAL this_item.variables.illusion_cooldown_{ID} less_than_equal_to 0}
            [then]

                #if ability is used by an enemy (most likely), try to aim at the player characters. if the ability is on an ally, just aim at a random enemy for now

                #TODO: for allies maybe make it prioritize targeting bosses

                {IF_VAR this_item.side equals $hoplite_enemyside (
                [then]
                    [store_unit]
                        [filter]
                            id=Hoplite,Hoplite2
                        [/filter]
                        variable=illusion_validtargets
                        kill=no
                    [/store_unit]
                [/then]
                [else]
                    [store_unit]
                        [filter]
                            [filter_side]
                                [enemy_of]
                                    side=$this_item.side
                                [/enemy_of]
                            [/filter_side]
                        [/filter]
                        variable=illusion_validtargets
                        kill=no
                    [/store_unit]
                [/else]
                )}

                #length is always 1 more than actual max index, so randing from 1 to length, then subtracting
                {VARIABLE_OP illusion_chosen_target_index rand 1..$illusion_validtargets.length}
                {VARIABLE_OP illusion_chosen_target_index sub 1}

                [store_unit]
                    [filter]
                        id=$illusion_validtargets[$illusion_chosen_target_index].id
                    [/filter]
                    variable=illusion_targetloc
                    kill=no
                [/store_unit]

                {CLEAR_VARIABLE illusion_validtargets}

#replaced hide_unit with store_unit, otherwise the reaper could block his own wraiths from spawning if he was on one of the spawn tiles

#                [hide_unit]
#                    id=$this_item.id
#                [/hide_unit]

                 [store_unit]
                     [filter]
                         id=$this_item.id
                     [/filter]
                     variable=tmp_illusion_{ID}_trying_to_store
                     kill=yes
                     mode=append
                 [/store_unit]

                {ILLUSION_WRAITHS_EVENT_PART {ID} n}
                {ILLUSION_WRAITHS_EVENT_PART {ID} ne}
                {ILLUSION_WRAITHS_EVENT_PART {ID} nw}
                {ILLUSION_WRAITHS_EVENT_PART {ID} s}
                {ILLUSION_WRAITHS_EVENT_PART {ID} se}
                {ILLUSION_WRAITHS_EVENT_PART {ID} sw}
                [store_unit]
                    [filter]
                        side=$hoplite_allyside
                        level=0,1
                        [filter_location]
                            [filter]
                                type=$this_item.abilities.hoplite_illusion_{ID}.wraith_type
                            [/filter]
                            radius=2
                        [/filter_location]
                    [/filter]
                    kill=no
                    variable=slowed
                [/store_unit]

                [foreach]
                    array=slowed
                    index_var=a
                    [do]
                        {VARIABLE this_item.status.slowed yes}
                        [unstore_unit]
                            variable=this_item
                        [/unstore_unit]
                    [/do]
                [/foreach]

                {CLEAR_VARIABLE slowed}
                [if]
                    [have_unit]
                        side=$this_item.side
                        type=$this_item.abilities.hoplite_illusion_{ID}.wraith_type
                    [/have_unit]
                    [then]
                        [unstore_unit]
                            variable=tmp_illusion_{ID}_trying_to_store
                            find_vacant=yes
                        [/unstore_unit]
                        {CLEAR_VARIABLE tmp_illusion_{ID}_trying_to_store}
                        [modify_unit]
                            [filter]
                                id=$this_item.id
                            [/filter]
                            [set_variable]
                                name=illusion_cooldown_{ID}
                                value=$this_item.abilities.hoplite_illusion_{ID}.cooldown
                            [/set_variable]
                        [/modify_unit]
                        [store_unit]
                            [filter]
                                id=$this_item.id
                            [/filter]
                            variable=illusion_stored_{ID}
                            kill=yes
                            mode=append
                        [/store_unit]
                        {SPARTAN_ILLUSION_CHOOSE_ONE_ILLUSION_TO_BE_REAL this_item {ID}}
                    [/then]
                    [else]
                        #if there is no valid spawn tiles, simply unstore the unit
                        [unstore_unit]
                            variable=tmp_illusion_{ID}_trying_to_store
                            find_vacant=yes
                        [/unstore_unit]
                        {CLEAR_VARIABLE tmp_illusion_{ID}_trying_to_store}
                    [/else]
                [/if]
            [/then]
            [/if]

            [/do]
        [/foreach]

        {CLEAR_VARIABLE grimreaper_hoplite_loc}
        {CLEAR_VARIABLE reaperclone}
    [/event]

    #reset reaper variables when going to another depth
    [event]
        name=spartan_custom_predescent_events
        id=spartan_erase_illusion_vars{ID}
        first_time_only=no
        [filter_condition]
            {VARIABLE_CONDITIONAL illusion_stored_{ID}.length greater_than 0}
        [/filter_condition]
        {CLEAR_VARIABLE illusion_stored_{ID}}
#        {CLEAR_VARIABLE real_illusion_{ID}}
    [/event]

#    #failsafe in case all reaper shadows disappear without triggering the unstore event AND reaper was the last enemy, force unstore the reaper
    [event]
        name=moveto
        id=spartan_illusion_failsafe2{ID}
        first_time_only=no
        [filter_condition]
            {VARIABLE_CONDITIONAL illusion_stored_{ID}.length greater_than 0}
        [/filter_condition]
        {SPARTAN_ILLUSION_ANTI_SOFTLOCK {ID}}
    [/event]

    [event]
        name=last breath
        id=spartan_illusion_wraith_defeated_{ID}
        first_time_only=no
        [filter]
            ability=spartan_illusion_wraith_{ID}
        [/filter]
        #added if check, otherwise overkill would check the other wraiths instead of the real reaper one:
        {IF_VAR reaper_being_unstored not_equals yes (
            [then]
                {VARIABLE illusion_overkill $unit.hitpoints}#damage to carry over from the wraith to grim reaper
                {VARIABLE_OP illusion_overkill sub $unit.max_hitpoints}
                {VARIABLE_OP illusion_overkill multiply -1}
                {CHATMSG $illusion_overkill}
            [/then]
        )}
        [if]
            {VARIABLE_CONDITIONAL unit.variables.illusion_stored_id not_equals $spartan_emptyvar}
            [then]

                [foreach]
                    array=illusion_stored_{ID}
                    index_var=a
                    [do]
                        [if]
                            {VARIABLE_CONDITIONAL this_item.id equals $unit.variables.illusion_stored_id}
                            [then]
                                {VARIABLE tmp_illusion_unstore_index $a}
                                {VARIABLE tmp_illusion_unstore_found_valid_unit yes}
                                [break]
                                [/break]
                            [/then]
                        [/if]
                    [/do]
                [/foreach]
                [if]
                {VARIABLE_CONDITIONAL tmp_illusion_unstore_found_valid_unit equals yes}
                [then]

                [kill]
                    x,y=$x1,$y1
                    animate=no
                    fire_event=no
                [/kill]
                        {VARIABLE illusion_stored_{ID}[$tmp_illusion_unstore_index].attacks_left 0}
                        {VARIABLE illusion_stored_{ID}[$tmp_illusion_unstore_index].moves 0}
                        [unstore_unit]
                            variable=illusion_stored_{ID}[$tmp_illusion_unstore_index]
                            x,y=$x1,$y1
                        [/unstore_unit]
                        {VARIABLE tmp_ability_filter_for_wraiths spartan_illusion_wraith_owned_by_$illusion_stored_{ID}[$tmp_illusion_unstore_index].id}
                        {CLEAR_VARIABLE illusion_stored_{ID}[$tmp_illusion_unstore_index]}
                        #no longer needed
                        #[unhide_unit]
                        #    ability=hoplite_illusion_{ID}
                        #[/unhide_unit]

                        #clear these variables before killing wraiths to avoid more bugs

                        {CLEAR_VARIABLE tmp_illusion_unstore_index}
                        {CLEAR_VARIABLE tmp_illusion_unstore_found_valid_unit}

                        {VARIABLE reaper_being_unstored yes}
                        [kill]
                            ability=$tmp_ability_filter_for_wraiths
                            animate=no
                            fire_event=yes
                        [/kill]
                        {CLEAR_VARIABLE reaper_being_unstored}
                        {CLEAR_VARIABLE tmp_ability_filter_for_wraiths}

                {IF_VAR reaper_being_unstored not_equals yes (
                    [and]
                        {VARIABLE_CONDITIONAL illusion_overkill greater_than 0}
                    [/and]
                    [then]
                        [spartan_harm_unit]
                            [filter]
                                x,y=$x1,$y1
                            [/filter]
                            [filter_second]
                                id=$second_unit.id
                            [/filter_second]
                            amount=$illusion_overkill
                            animate=defender
                            fire_event=yes
                            delay=0
                            experience=no
                        [/spartan_harm_unit]
                        {CLEAR_VARIABLE illusion_overkill}
                    [/then]
                )}
                [/then]
                [/if]
            [/then]
            [else]
            [/else]
        [/if]
        {IF_VAR reaper_being_unstored not_equals yes (
            [then]
                {CLEAR_VARIABLE illusion_overkill}
            [/then]
        )}
        {CLEAR_VARIABLE tmp_illusion_unstore_index}
        {CLEAR_VARIABLE tmp_illusion_unstore_found_valid_unit}
    [/event]
[+abilities]
#enddef



#define WEAPON_SPECIAL_SPARTAN_LONG_SLOW
    # Canned definition of the Slow ability to be included in a
    # [specials] clause.
    [slow]
        id=spartan_long_slow
        name= _ "long slow"
        description= _ "Works like slow, but lasts for 2 turns instead of 1 turn. Does not work on bosses (they are only slowed for 1 turn). Only direct attacks slow for longer, not sweeping slow (unless you have the 'sweeping long slow special')."
    [/slow]
#enddef

#define WEAPON_SPECIAL_SPARTAN_SWEEPING_LONG_SLOW
    [dummy]
        id=spartan_sweeping_longslow
        name=_"sweeping long slow"
        description=_"This attack can long-slow several enemies at once (slows enemies that are adjacent to both you and the target). Long slow works like slow, but lasts for 2 turns instead of 1 turn. Does not work on bosses (they are only slowed for 1 turn). "
    [/dummy]
#enddef

#define SPARTAN_APPLY_LONG_SLOW TURNS FILTER
    #apply long slow to non-bosses, apply normal slow to any unit
    [modify_unit]
        [filter]
            [not]
                ability=hoplite_boss_immunities
            [/not]
            [and]
                {FILTER}
            [/and]
        [/filter]
        {VARIABLE long_slow_turns_left {TURNS}}
    [/modify_unit]
    [modify_unit]
        [filter]
            {FILTER}
        [/filter]
        [status]
            slowed=yes
        [/status]
    [/modify_unit]
#enddef

#define SPARTAN_LONG_SLOW_EVENTS

    #long slow events
    [event]
        name=attacker hits
        id=spartan_long_slow
        first_time_only=no
        [filter_attack]
            special_id=spartan_long_slow
        [/filter_attack]
        {SPARTAN_APPLY_LONG_SLOW 1 id=$second_unit.id}
    [/event]

    [event]
        name=side turn end#slow is reapplied right after it wears off
        id=spartan_long_slow_apply
        first_time_only=no
        [filter_condition]
            [have_unit]
                side=$side_number
                formula="self.wml_vars.long_slow_turns_left > 0"
            [/have_unit]
        [/filter_condition]

        [store_unit]
            [filter]
                side=$side_number
                formula="self.wml_vars.long_slow_turns_left > 0"
            [/filter]
            variable=long_slow_units
            kill=no
        [/store_unit]

        [foreach]
            array=long_slow_units
            index_var=i
            [do]

            #if timer is about to run out, clear variable instead of subtracting

            [if]
            {VARIABLE_CONDITIONAL this_item.variables.long_slow_turns_left less_than_equal_to 1}
            [then]
            [modify_unit]
                [filter]
                    id=$this_item.id
                [/filter]
                [status]
                    slowed=yes
                [/status]
                {CLEAR_VARIABLE long_slow_turns_left}
            [/modify_unit]
            [/then]
            [else]
            [modify_unit]
                [filter]
                    id=$this_item.id
                [/filter]
                [status]
                    slowed=yes
                [/status]
                {VARIABLE_OP long_slow_turns_left sub 1}
            [/modify_unit]
            [/else]
            [/if]

            #commented out for now

            #[floating_text]
            #    x,y=$this_item.x,$this_item.y
            #    text=_"<span color='#0000ff'>long slow</span>"
            #[/floating_text]

            [/do]
        [/foreach]

        {CLEAR_VARIABLE long_slow_units}
    [/event]

#enddef


#define SPARTAN_FINISH_OFF_HP_COMPARE OPERATOR MULT
    formula="(self.hitpoints {OPERATOR} self.max_hitpoints * {MULT})"
#enddef

#unlike GSE, it's flat instead of percentile

#define WEAPON_SPECIAL_SPARTAN_FINISHOFF VALUE
[damage]
    id=spartan_finishoff
    name=_"finish off"+" {VALUE}"
    description=_"This attack deals"+" {VALUE} "+_"more damage if the opponent has 50% or less hitpoints. Only works on offense, not counterattacks."
    add={VALUE}
    apply_to=self
    active_on=offense
    [filter_opponent]
        {SPARTAN_FINISH_OFF_HP_COMPARE <= 0.5}
    [/filter_opponent]
[/damage]
#enddef