#textdomain wesnoth-Hoplite

#old ability
##define ABILITY_RANGED
##dummy ability used for indentifying ranged units, instead of having unit types pasted everywhere
#    [dummy]
#        id=hoplite_ranged
#    [/dummy]
##enddef

#define ABILITY_SPARTAN_RANGED RADIUS
#dummy ability used for indentifying ranged units, instead of having unit types pasted everywhere
    [dummy]
        id=hoplite_ranged
    [/dummy]
    [dummy]
        id=hoplite_ranged_ai{RADIUS}#for checking how close a ranged unit should be to players to attack
    [/dummy]
#enddef

#TODO: try to rework the microai so it's merged into fewer of them, to reduce lag a little

#define SPARTAN_RANGED_MICROAI RADIUS
    [micro_ai]
        side=$hoplite_enemyside
        ai_type=goto
        action=add
        id=enemyranged_aim_at_player{RADIUS}
        [filter]
            ability=hoplite_ranged_ai{RADIUS}
        [/filter]
        [filter_location]
            find_in=spartan_enemyranged_ai_locs
            [and]
                [filter]
                    side=$hoplite_playerside,$hoplite_allyside
                [/filter]
                radius={RADIUS}
            [/and]
            #doesn't waste turns trying to move to occupied locs
            [not]
                [filter]
                    [not]
                        ability=hoplite_ranged_ai{RADIUS}#exception to make AI not move forward
                    [/not]
                [/filter]
            [/not]
        [/filter_location]
        ca_score=140000#high but lower than coward ai
        unique_goals=yes
        remove_movement=no
    [/micro_ai]
    [micro_ai]
        side=$hoplite_enemyside
        ai_type=goto
        action=add
        id=enemyranged_aim_at_player_semiranged{RADIUS}
        [filter]
            ability=hoplite_semiranged_ai{RADIUS}
            [not]
                [filter_location]
                [filter]
                    side=$hoplite_playerside,$hoplite_allyside
                [/filter]
                radius=2
                [/filter_location]
            [/not]
        [/filter]
        [filter_location]
            find_in=spartan_enemyranged_ai_locs
            [and]
                [filter]
                    side=$hoplite_playerside,$hoplite_allyside
                [/filter]
                radius={RADIUS}
            [/and]
            #doesn't waste turns trying to move to occupied locs
            [not]
                [filter]
                    [not]
                        ability=hoplite_semiranged_ai{RADIUS}#exception to make AI not move forward
                    [/not]
                [/filter]
            [/not]
        [/filter_location]
        ca_score=140000#high but lower than coward ai
        unique_goals=yes
        remove_movement=no
    [/micro_ai]
    [micro_ai]
        side=$hoplite_allyside
        ai_type=goto
        action=add
        id=allyranged_aim_at_enemies{RADIUS}
        [filter]
            ability=hoplite_ranged_ai{RADIUS}
        [/filter]
        [filter_location]
            find_in=spartan_allyranged_ai_locs
            [and]
                [filter]
                    side=$hoplite_enemyside
                [/filter]
                radius={RADIUS}
            [/and]
            #doesn't waste turns trying to move to occupied locs
            [not]
                [filter]
                    [not]
                        ability=hoplite_ranged_ai{RADIUS}#exception to make AI not move forward
                    [/not]
                [/filter]
            [/not]
        [/filter_location]
        ca_score=140000#high but lower than coward ai
        unique_goals=yes
        remove_movement=no
    [/micro_ai]
    [micro_ai]
        side=$hoplite_allyside
        ai_type=goto
        action=add
        id=allyranged_aim_at_enemies_semiranged{RADIUS}
        [filter]
            ability=hoplite_semiranged_ai{RADIUS}
            [not]
                [filter_location]
                [filter]
                    side=$hoplite_enemyside
                [/filter]
                radius=2
                [/filter_location]
            [/not]
        [/filter]
        [filter_location]
            find_in=spartan_allyranged_ai_locs
            [and]
                [filter]
                    side=$hoplite_enemyside
                [/filter]
                radius={RADIUS}
            [/and]
            #doesn't waste turns trying to move to occupied locs
            [not]
                [filter]
                    [not]
                        ability=hoplite_semiranged_ai{RADIUS}#exception to make AI not move forward
                    [/not]
                [/filter]
            [/not]
        [/filter_location]
        ca_score=140000#high but lower than coward ai
        unique_goals=yes
        remove_movement=no
    [/micro_ai]
#enddef

##define ABILITY_SEMIRANGED
##for units like cuttlefish, for whom the coward ai is not needed
#    [dummy]
#        id=hoplite_semiranged
#    [/dummy]
##enddef

#define ABILITY_SPARTAN_SEMIRANGED RADIUS
#for units like cuttlefish, for whom the coward ai is not needed
    [dummy]
        id=hoplite_semiranged
    [/dummy]
    [dummy]
        id=hoplite_semiranged_ai{RADIUS}#for checking how close a ranged unit should be to players to attack
    [/dummy]
#enddef

#define TARGETUNITS_FILTER_PART VAR DIR
    [filter_location]
        find_in=ranged_targetlocs{DIR}
    [/filter_location]
#enddef

#define STORE_TARGETLOCS_PART VAR DIR DISTANCE BLINDSPOT
#    [chat]
#        message={DIR}
#    [/chat]
#    [chat]
#        message={DISTANCE}
#    [/chat]
#    [chat]
#        message={BLINDSPOT}
#    [/chat]
#    [chat]
#        message="${VAR}.x|,${VAR}.y|"
#    [/chat]
    {VARIABLE previousloc.x ${VAR}.x}
    {VARIABLE previousloc.y ${VAR}.y}
#reversing direction, and avoid accidentally inputting a variable without the | at the end in variable names below
    {VARIABLE tmp_targetloc_dir {DIR}}
    {VARIABLE blindspot_index -1}
    {REPEAT {BLINDSPOT} (
        [store_locations]
            terrain=!,{SPARTAN_WALL_TERRAIN}
            [filter_adjacent_location]
                x,y=$previousloc.x,$previousloc.y
                adjacent=$tmp_targetloc_dir|
            [/filter_adjacent_location]
            variable=ranged_blindspots$tmp_targetloc_dir|
            include_borders=no
            mode=append
        [/store_locations]
        {VARIABLE_OP blindspot_index add 1}
        {IF_VAR ranged_blindspots$tmp_targetloc_dir|[$blindspot_index].x greater_than 0 (
        [then]
            {VARIABLE previousloc.x $ranged_blindspots$tmp_targetloc_dir|[$blindspot_index].x}
            {VARIABLE previousloc.y $ranged_blindspots$tmp_targetloc_dir|[$blindspot_index].y}
        [/then]
        )}
    )}

    {VARIABLE ranged_truerange {DISTANCE}}
    {VARIABLE_OP ranged_truerange sub {BLINDSPOT}}
    {VARIABLE targetloc_index -1}

    {REPEAT $ranged_truerange (
        [store_locations]
            terrain=!,{SPARTAN_WALL_TERRAIN}
            [filter_adjacent_location]
                x,y=$previousloc.x,$previousloc.y
                adjacent=$tmp_targetloc_dir|
            [/filter_adjacent_location]
            variable=ranged_targetlocs$tmp_targetloc_dir|
            include_borders=no
            mode=append
        [/store_locations]
        {VARIABLE_OP targetloc_index add 1}
        {IF_VAR ranged_targetlocs$tmp_targetloc_dir|[$targetloc_index].x greater_than 0 (
        [then]
            {VARIABLE previousloc.x $ranged_targetlocs$tmp_targetloc_dir|[$targetloc_index].x}
            {VARIABLE previousloc.y $ranged_targetlocs$tmp_targetloc_dir|[$targetloc_index].y}
        [/then]
        )}
    )}
    {CLEAR_VARIABLE tmp_targetloc_dir}
#enddef

#define SPARTAN_PLACE_TARGETHEXES LOCATIONVAR UNITVAR RANGE BLINDSPOT TARGETHEX_IMG
            [foreach]
                array={LOCATIONVAR}
                variable=this_item2
                index_var=e
                [do]

#                {CHATMSG "foreach targetloc"$this_item2.x|,$this_item2.y|}

                [set_variables]
                    name=tmp_item_tag_container
                    [value]
                        x=$this_item2.x
                        y=$this_item2.y
                        image={TARGETHEX_IMG}
                        name=hoplite_targethex${UNITVAR}.id
                    [/value]
                [/set_variables]

                #am using [insert_tag] instead of just item, otherwise the game doesn't substitute the id variable for some reason

                [insert_tag]
                    name=item
                    variable=tmp_item_tag_container
                [/insert_tag]

                {CLEAR_VARIABLE tmp_item_tag_container}

#                [item]
#                    x,y=$this_item2.x,$this_item2.y
#                    image="misc/targethex-archer.png"
#                    name=hoplite_targethex$|this_item.id
#                [/item]

#                [store_locations]
#                    x,y=$this_item2.x,$this_item2.y
#                    variable=$this_item.id|targethexes
#                    mode=append
#                [/store_locations]

                [set_variables]
                    name=hoplite_targethexes
                    mode=append
                    [value]
                        unit_id=${UNITVAR}.id
                        x=$this_item2.x
                        y=$this_item2.y
                        unit_x=${UNITVAR}.x
                        unit_y=${UNITVAR}.y
                        name=hoplite_targethex${UNITVAR}.id
                        attack_range={RANGE}
                        attack_blindspot={BLINDSPOT}
                        attack_aimdir=$tmp_ranged_dir
                        targethex_img={TARGETHEX_IMG}
                    [/value]
                [/set_variables]

                [/do]
            [/foreach]
#enddef

#define CLEAR_DIRECTIONAL_VARS VAR
{CLEAR_VARIABLE {VAR}n}
{CLEAR_VARIABLE {VAR}ne}
{CLEAR_VARIABLE {VAR}nw}
{CLEAR_VARIABLE {VAR}s}
{CLEAR_VARIABLE {VAR}se}
{CLEAR_VARIABLE {VAR}sw}
#enddef

#define HOPLITE_CLEAR_TMP_TARGETHEXES
    {CLEAR_DIRECTIONAL_VARS ranged_blindspots}
    {CLEAR_DIRECTIONAL_VARS ranged_targetlocs}
#enddef

#define HOPLITE_REMOVE_CURRENT_TARGEHEX INDEX
    [set_variables]
        name=tmp_remove_item_tag_container
        [value]
            x=$hoplite_targethexes[{INDEX}].x
            y=$hoplite_targethexes[{INDEX}].y
            image=$hoplite_targethexes[{INDEX}].name
        [/value]
    [/set_variables]

    #am using [insert_tag] instead of just remove_item, otherwise the game doesn't substitute the id variable for some reason

    [insert_tag]
        name=remove_item
        variable=tmp_remove_item_tag_container
    [/insert_tag]
    
    [redraw][/redraw]

    {CLEAR_VARIABLE tmp_remove_item_tag_container}
#enddef

#define HOPLITE_CLEAR_TARGETHEXES_BY_ID ID
#using a while loop (original deprecated FOREACH implementation) instead of foreach as it's better for deleting array elements
{VARIABLE c 0}
[while]
    [variable]
    name=c
    less_than=$hoplite_targethexes.length
    [/variable]
    [do]
        {IF_VAR hoplite_targethexes[$c].unit_id equals {ID} (
            [then]
                {HOPLITE_REMOVE_CURRENT_TARGEHEX $c}
                {CLEAR_VARIABLE hoplite_targethexes[$c]}
                {VARIABLE_OP c sub 1}#this is to fix weirdness when something in an array is deleted
            [/then]
        )}
    [set_variable]
    name=c
    add=1
    [/set_variable]
    [/do]
[/while]
{CLEAR_VARIABLE c}
#enddef

#TODO: use this in level generation code for going into next depth

#define HOPLITE_CLEAR_ALL_TARGETHEXES
#using a while loop (original deprecated FOREACH implementation) instead of foreach as it's better for deleting array elements
{VARIABLE c 0}
[while]
    [variable]
    name=c
    less_than=$hoplite_targethexes.length
    [/variable]
    [do]
        {HOPLITE_REMOVE_CURRENT_TARGEHEX $c}
        {CLEAR_VARIABLE hoplite_targethexes[$c]}
#        {VARIABLE_OP c sub 1}#this is to fix weirdness when something in an array is deleted
#    [set_variable]
#    name=c
#    add=1
#    [/set_variable]
    [/do]
[/while]
{CLEAR_VARIABLE c}
#enddef

#define HOPLITE_CLEAR_TARGETHEXES_IF_UNIT_NOT_FOUND
#using a while loop (original deprecated FOREACH implementation) instead of foreach as it's better for deleting array elements
{VARIABLE clear_targethexes_index 0}
[while]
    [variable]
    name=clear_targethexes_index
    less_than=$hoplite_targethexes.length
    [/variable]
    [do]
        [if]
        [have_unit]
            id=$hoplite_targethexes[$clear_targethexes_index].unit_id
            #slowed units can't use ranged attacks anyway, so clear the targethexes
            [not]
                [filter_wml]
                    [status]
                        slowed=yes
                    [/status]
                [/filter_wml]
            [/not]
#            [and]
#                x,y=$hoplite_targethexes[$clear_targethexes_index].unit_x,$hoplite_targethexes[$clear_targethexes_index].unit_y
#            [/and]
        [/have_unit]
        [then]
            [if]
            [have_unit]
                id=$hoplite_targethexes[$clear_targethexes_index].unit_id
                [not]
                    x,y=$hoplite_targethexes[$clear_targethexes_index].unit_x,$hoplite_targethexes[$clear_targethexes_index].unit_y
                [/not]
            [/have_unit]
            [then]
                {HOPLITE_UPDATE_TARGETHEXES_BY_ID $hoplite_targethexes[$clear_targethexes_index].unit_id}
            [/then]
            [/if]
        [/then]
        [else]
            {HOPLITE_REMOVE_CURRENT_TARGEHEX $clear_targethexes_index}    
            {CLEAR_VARIABLE hoplite_targethexes[$clear_targethexes_index]}
            {VARIABLE_OP clear_targethexes_index sub 1}#this is to fix weirdness when something in an array is deleted
        [/else]
        [/if]
    [set_variable]
    name=clear_targethexes_index
    add=1
    [/set_variable]
    [/do]
[/while]
{CLEAR_VARIABLE clear_targethexes_index}
#enddef

#define HOPLITE_UPDATE_TARGETHEXES_BY_ID ID
#using a while loop (original deprecated FOREACH implementation) instead of foreach as it's better for deleting array elements
{VARIABLE c 0}
{VARIABLE tmp_spartan_rangedunitfound no}
[while]
    [variable]
    name=c
    less_than=$hoplite_targethexes.length
    [/variable]
    [and]
        {VARIABLE_CONDITIONAL tmp_spartan_rangedunitfound equals no}
    [/and]
    [do]
        [if]
        [have_unit]
            id=$hoplite_targethexes[$c].unit_id
        [/have_unit]
        [and]
            {VARIABLE_CONDITIONAL hoplite_targethexes[$c].unit_id equals {ID}}
        [/and]
        [then]
            [if]
            [have_unit]
                id=$hoplite_targethexes[$c].unit_id
                [not]
                    x,y=$hoplite_targethexes[$c].unit_x,$hoplite_targethexes[$c].unit_y
                [/not]
            [/have_unit]
            [then]
                {VARIABLE tmp_spartan_rangedunitfound yes}

                [set_variables]
                    name=tmp_hoplite_targethex_copy
                    to_variable=hoplite_targethexes[$c]
                [/set_variables]

#                {VARIABLE tmp_hoplite_targethex_copy $hoplite_targethexes[$c]}
 
                #TODO: store the targetloc FIRST as copy, then clear it, then use the copy for targetplacement code

                [store_unit]
                    [filter]
                        id=$hoplite_targethexes[$c].unit_id
                    [/filter]
                    variable=tmp_hoplite_targethex_moved_unit
                    kill=no
                [/store_unit]

                {HOPLITE_CLEAR_TARGETHEXES_BY_ID $hoplite_targethexes[$c].unit_id}
                {SPARTAN_GET_RANGED_ATTACK_INDEX tmp_hoplite_targethex_moved_unit}
                {STORE_TARGETHEX_LOC tmp_hoplite_targethex_moved_unit $tmp_hoplite_targethex_moved_unit.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.range $tmp_hoplite_targethex_moved_unit.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.blindspot}

                {VARIABLE tmp_ranged_dir $tmp_hoplite_targethex_copy.attack_aimdir}

#                [chat]
#                    message=_"range/blindspot/dir/targethex img: $tmp_hoplite_targethex_moved_unit.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.range|/$tmp_hoplite_targethex_moved_unit.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.blindspot|/$tmp_ranged_dir|/$tmp_hoplite_targethex_moved_unit.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.targethex_img|"
#                [/chat]

                {SPARTAN_PLACE_TARGETHEXES ranged_targetlocs$tmp_ranged_dir tmp_hoplite_targethex_moved_unit $tmp_hoplite_targethex_moved_unit.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.range $tmp_hoplite_targethex_moved_unit.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.blindspot $tmp_hoplite_targethex_moved_unit.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.targethex_img}

                {CLEAR_VARIABLE tmp_hoplite_targethex_moved_unit}

                {HOPLITE_CLEAR_TMP_TARGETHEXES}
            
                {CLEAR_VARIABLE tmp_ranged_dir}
                {CLEAR_VARIABLE tmp_spartan_ranged_index}
            [/then]
            [/if]
        [/then]
        [else]
            [if]
            [have_unit]
                id=$hoplite_targethexes[$c].unit_id
            [/have_unit]
            [else]
            {HOPLITE_REMOVE_CURRENT_TARGEHEX $c}            
            {CLEAR_VARIABLE hoplite_targethexes[$c]}
            {VARIABLE_OP c sub 1}#this is to fix weirdness when something in an array is deleted
            [/else]
            [/if]
        [/else]
        [/if]
    [set_variable]
    name=c
    add=1
    [/set_variable]
    [/do]
[/while]
{CLEAR_VARIABLE c}
{CLEAR_VARIABLE tmp_spartan_rangedunitfound}
#enddef

#define HOPLITE_IFHAVELOC LOC1 DIR DISTANCE BLINDSPOT STORELOC
    [store_locations]
        [filter_adjacent_location]
            x,y={LOC1}
            adjacent={DIR}
        [/filter_adjacent_location]
        variable=targethex_test
        include_borders=no
    [/store_locations]
    [if]
        [have_location]
            x=$targethex_test.x
            y=$targethex_test.y
        [not]
            terrain={SPARTAN_WALL_TERRAIN}
        [/not]
        [filter_adjacent_location]
                x,y={LOC1}
        [/filter_adjacent_location]
#            [and]
#                x,y={LOC1}
#                radius=1
#            [/and]
        [/have_location]
    [and]
        [have_location]
            x=$targethex_test.x
            y=$targethex_test.y
        [/have_location]
    [/and]
    [and]
        [have_location]
            x,y={LOC1}
        terrain=!,{SPARTAN_WALL_TERRAIN}
        [/have_location]
    [/and]
        [then]
            {STORELOC}
        [/then]
        [else]
        [/else]
    [/if]
    {CLEAR_VARIABLE targethex_test}
#enddef

#define STORE_TARGETHEX_LOC VAR DISTANCE BLINDSPOT
    {STORE_TARGETLOCS_PART {VAR} n {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART {VAR} ne {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART {VAR} nw {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART {VAR} s {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART {VAR} se {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART {VAR} sw {DISTANCE} {BLINDSPOT}}
#enddef

#define STORE_TARGETHEX_LOC_WITH_DIRECTION_LIST VAR DIRECTIONS DISTANCE BLINDSPOT
    [set_variables]
        name=tmp_aim_directions
        [split]
            list={DIRECTIONS}
            key=dir
            separator=,
        [/split]
    [/set_variables]
    [foreach]
       array=tmp_aim_directions
       index_var=aim_index
       variable=this_aimdir
       [do]
#            [chat]
#                message=$this_aimdir.dir
#            [/chat]
            {STORE_TARGETLOCS_PART {VAR} $this_aimdir.dir {DISTANCE} {BLINDSPOT}}
       [/do]
    [/foreach]
    {CLEAR_VARIABLE tmp_aim_directions}
    {CLEAR_VARIABLE tmp_inputloc}
#enddef

#define TARGETUNITS_FILTER VAR
    {TARGETUNITS_FILTER_PART {VAR} n}
    [or]
    {TARGETUNITS_FILTER_PART {VAR} ne}
    [/or]
    [or]
    {TARGETUNITS_FILTER_PART {VAR} nw}
    [/or]
    [or]
    {TARGETUNITS_FILTER_PART {VAR} s}
    [/or]
    [or]
    {TARGETUNITS_FILTER_PART {VAR} se}
    [/or]
    [or]
    {TARGETUNITS_FILTER_PART {VAR} sw}
    [/or]
#enddef

#stores the targethexes of a specific unit
#define STORE_TARGETHEXES_OF_ID ID VAR
    [foreach]
        array=hoplite_targethexes
        variable=this_targethex
        index_var=e
        [do]
            {IF_VAR this_targethex.unit_id equals {ID} (
            [then]
            [store_locations]
                find_in=this_targethex
                variable={VAR}
                include_borders=no
                mode=append
            [/store_locations]
            [/then]
            )}
        [/do]
    [/foreach]
#enddef

#NOTE: only works for units with one ranged attack. multiple ranged attacks on one unit are unsupported by current code for now

#define SPARTAN_GET_RANGED_ATTACK_INDEX UNITVAR
    [foreach]
        array={UNITVAR}.attack
        index_var=a
        variable=this_weapon
        [do]
#            [chat]
#                message=$a
#            [/chat]
            [if]
                {VARIABLE_CONDITIONAL this_weapon.specials.spartan_ranged.range not_equals $emptyvar}
                [then]
                    {VARIABLE tmp_spartan_ranged_index $a}
                    #[chat]
                    #    message="found weapon at index $a"
                    #[/chat]
                [/then]
            [/if]
        [/do]
    [/foreach]
#enddef

#several "wrapper" macros for ranged attacks, this is to make it easier for me to add new parameters to ranged attacks without needing to edit tons of unit code (just add () to unused parameters inside wrapper macros )

#define WEAPON_SPECIAL_HOPLITE_RANGED ID RANGE BLINDSPOT TARGETHEX_IMG TARGETING_TYPE MISC_PARAMETERS ONHIT_EFFECTS ONMISS_EFFECTS
    {HOPLITE_RANGED_MACRO_SHARED {ID} {RANGE} {BLINDSPOT} {TARGETHEX_IMG} {TARGETING_TYPE} {MISC_PARAMETERS}}
[/specials]
[/attack]
    {SPARTAN_RANGED_EVENTS}
    #onhit/onmiss code is now moved to seperate events, as part of mu "make the ranged code more modular and make events less hardcoded per unit" plan
    [event]
        id=spartan_ranged_onhit_effects_{ID}
        first_time_only=no
        {ONHIT_EFFECTS}
    [/event]
    [event]
        id=spartan_ranged_onmiss_effects_{ID}
        first_time_only=no
        {ONMISS_EFFECTS}
    [/event]
[+attack]
[+specials]
#enddef

#this wrapper is no longer needed now that miss effects have been moved to main wrapper

##define WEAPON_SPECIAL_HOPLITE_RANGED_WITH_MISS_EFFECT ID ATTACK_INDEX RANGE BLINDSPOT TARGETHEX_IMG TARGETING_TYPE MISC_PARAMETERS ONHIT_EFFECTS ONMISS_EFFECTS
#    {HOPLITE_RANGED_MACRO_SHARED {ID} {RANGE} {BLINDSPOT} {TARGETHEX_IMG} {TARGETING_TYPE} {MISC_PARAMETERS} {ONHIT_EFFECTS} {ONMISS_EFFECTS}}
#[/specials]
#[/attack]
#    {SPARTAN_RANGED_EVENTS {ID} {ONHIT_EFFECTS} {ONMISS_EFFECTS}}
#[+attack]
#[+specials]
##enddef

#define HOPLITE_RANGED_MACRO_SHARED ID RANGE BLINDSPOT TARGETHEX_IMG TARGETING_TYPE MISC_PARAMETERS
#TODO: rangedtype values:
 #first: targets the first enemy in a direction
 #aoe: targets every enemy in a direction
 #first_blockeally: like first, but doesn't pick the direction if there is an ally in the way
 #aoe_blockally: like aoe, but doesn't pick the direction if there is an ally in the way
 #random: randomly picks an enemy in the chosen direction
 #SCRAPPED: assassin: always aims for player characters or bosses, even if there is a weaker enemy in the way, can shoot through own allies
    [spartan_ranged]
        id=hoplite_ranged
        name= _ "ranged attack"
        description=_"Unlike normal wesnoth, ranged attacks can attack over a distance of multiple tiles. At the start of the player turn, all ranged units will aim at enemies, and the hexes they can shoot at will be highlighted (yellow for single-target attacks, red for AOE attacks, blue for slowing attacks)"
        #TODO: use this instead of the {ID} macro in some parts of the code
        rangedattack_id={ID}
        range={RANGE}
        blindspot={BLINDSPOT}
        targethex_img={TARGETHEX_IMG}
        targeting_type={TARGETING_TYPE}
        {MISC_PARAMETERS}
    [/spartan_ranged] # wmlxgettext: [abilities]
    #IMPORTANT NOTE: shared macro does not include events (the wrappers have it instead). this is intended for editing ranged attacks in [effect]s, like buffing summoned archer's range, where the shared macro can be given directly
#enddef

#define SPARTAN_RANGED_EVENTS
[event]
    name=side turn end
    id=rangedcombat_aim
    first_time_only=no
    [filter_condition]
        [have_unit]
            side=$side_number
            [has_attack]
                special_id=hoplite_ranged
            [/has_attack]
            [not]
                [filter_wml]
                    [status]
                        slowed=yes
                    [/status]
                [/filter_wml]
#removed, as otherwise ranged cooldown never runs out
#                [or]
#                    formula="self.wml_vars.ranged_cooldown > 0"
#                [/or]
            [/not]
        [/have_unit]
    [/filter_condition]

    {CHATMSG "reworked ranged aim"}

    [store_unit]
        [filter]
            side=$side_number
            [has_attack]
                special_id=hoplite_ranged
            [/has_attack]
            [not]
                [filter_wml]
                    [status]
                        slowed=yes
                    [/status]
                [/filter_wml]
#removed, as otherwise ranged cooldown never runs out
#                [or]
#                    formula="self.wml_vars.ranged_cooldown > 0"
#                [/or]
            [/not]
        [/filter]
        variable=rangedunit_aiming
        kill=no
    [/store_unit]

    [foreach]
        array=rangedunit_aiming
        index_var=a
        [do]

        [if]
            [have_unit]
                id=$this_item.id
                [not]
                    formula="self.wml_vars.ranged_cooldown > 0"
                [/not]
            [/have_unit]
            [else]
            [modify_unit]
                [filter]
                    id=$this_item.id
                [/filter]
                [set_variable]
                    name=ranged_cooldown
                    sub=1
                [/set_variable]
            [/modify_unit]
            [/else]
            [then]

            {SPARTAN_GET_RANGED_ATTACK_INDEX this_item}
#            {STORE_TARGETHEX_LOC this_item $this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.range $this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.blindspot}

#if there is static directionlock, only aim in the specified directions. otherwise use all 6 default directions

            {IF_VAR this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.direction_lock_static not_equals $emptyvar (
            [then]
                {STORE_TARGETHEX_LOC_WITH_DIRECTION_LIST this_item $this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.direction_lock_static $this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.range $this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.blindspot}
            [/then]
            [else]
                {STORE_TARGETHEX_LOC_WITH_DIRECTION_LIST this_item n,ne,nw,s,se,sw $this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.range $this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.blindspot}
            [/else]
            )}

            {CLEAR_VARIABLE tmp_spartan_ranged_index}

#scrapped for now
#{IF_VAR tmp_targettype equals assassin (
#[then]
#    [store_unit]
#        [filter]
#            ability=hoplite_boss
#            [filter_side]
#                [enemy_of]
#                    side=$this_item.side
#                [/enemy_of]
#            [/filter_side]
#            {TARGETUNITS_FILTER this_item}
#            [not]
#                ability_type_active=hides
#            [/not]
#            [or]
#            side=$hoplite_playerside
#            [filter_side]
#                [enemy_of]
#                    side=$this_item.side
#                [/enemy_of]
#            [/filter_side]
#            {TARGETUNITS_FILTER this_item}
#            [not]
#                ability_type_active=hides
#            [/not]
#            [/or]
#        [/filter]
#        variable=rangedtarget_loc
#        kill=no
#    [/store_unit]
#[/then]
#)}

{IF_VAR rangedtarget_loc.length greater_than 0 (
[else]
    [store_unit]
        [filter]
            [filter_side]
                [enemy_of]
                    side=$this_item.side
                [/enemy_of]
            [/filter_side]
            [not]
                ability_type_active=hides
                [or]
                    ability=spartan_bombfilter#avoid targeting bombs
                [/or]
            [/not]
            [and]
            {TARGETUNITS_FILTER this_item}
            [/and]
        [/filter]
        variable=rangedtarget_loc
        kill=no
    [/store_unit]
[/else]
)}
    {RANDOM 0.."$($rangedtarget_loc.length| - 1)"}
#    [animate_unit]
#        flag=standing
#        [facing]
#            [filter]
#                x=$rangedtarget_loc[$random].x
#                y=$rangedtarget_loc[$random].y
#            [/filter]
#        [/facing]
#        [filter]
#            x=$this_item.x
#            y=$this_item.y
#        [/filter]
#    [/animate_unit]

    [if]
    {VARIABLE_CONDITIONAL rangedtarget_loc.length greater_than 0}
    [then]

    {SPARTAN_GETDIR_REVERSED $this_item.x $this_item.y $rangedtarget_loc[$random].x $rangedtarget_loc[$random].y tmp_ranged_dir}
#NOTE: forcibly setting a direction didn't seem to work
#EDIT: nvm, n is south here due to reversed dir
#    {VARIABLE tmp_ranged_dir n}#for debugging
#    {CHATMSG $tmp_ranged_dir}

    [/then]
    [/if]

    [if]
        [have_unit]
            [filter_side]
                [enemy_of]
                    side=$this_item.side
                [/enemy_of]
            [/filter_side]
            [filter_location]
                find_in=ranged_targetlocs$tmp_ranged_dir
            [/filter_location]
            [not]
                ability_type_active=hides
            [/not]
        [/have_unit]
        [then]
#            {CHATMSG "ranged target found 2"}


            {SPARTAN_GET_RANGED_ATTACK_INDEX this_item}

            {SPARTAN_PLACE_TARGETHEXES ranged_targetlocs$tmp_ranged_dir this_item $this_item.attack[$tmp_spartan_ranged_index].specials.spartan_ranged.range $this_item.attack[$tmp_spartan_ranged_index].specials.spartan_ranged.blindspot $this_item.attack[$tmp_spartan_ranged_index].specials.spartan_ranged.targethex_img}

            {CLEAR_VARIABLE tmp_spartan_ranged_index}

            [store_items]
                x=0-99
                y=0-99
                variable=stored_items
            [/store_items]

            [sound]
                name=magic-dark-big-miss.ogg
            [/sound]
            [object]
                silent=yes
                duration=turn
                [filter]
                    find_in=this_item
                [/filter]
                [effect]
                    apply_to=new_ability
                    [abilities]
                        [dummy]
                            id=hoplite_charging
                        [/dummy]
                    [/abilities]
                [/effect]
            [/object]
            {MODIFY_UNIT id=$this_item.id moves 0}
#removed since this is misleading
#            {MODIFY_UNIT id=$this_item.id max_moves 0}
        [/then]
    [/if]

    [delay]
        time=200
    [/delay]

#    {HOPLITE_CLEAR_TARGETHEXES_BY_ID $this_item.id}

    {HOPLITE_CLEAR_TMP_TARGETHEXES}

    [/then]
    [/if]

    {CLEAR_VARIABLE tmp_ranged_dir}
        [/do]
    [/foreach]

    {CLEAR_VARIABLE rangedunit_aiming}
[/event]
[event]
    name=side turn,die,attack end
    id=hoplite_clear_targethexes
    first_time_only=no
    {HOPLITE_CLEAR_TARGETHEXES_IF_UNIT_NOT_FOUND}
[/event]
[event]
    name=side turn
    id=rangedcombat
    {CHATMSG "reworked ranged combat"}
    first_time_only=no
    [if]
    [have_unit]
        [has_attack]
            special_id=hoplite_ranged
        [/has_attack]
    [/have_unit]
    [then]
    [store_unit]
        [filter]
            [has_attack]
                special_id=hoplite_ranged
            [/has_attack]
            [and]
                ability=hoplite_charging
            [/and]
            side=$side_number
            [not]
                [filter_wml]
                    [status]
                        slowed=yes
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        variable=rangedunit
        kill=no
    [/store_unit]
#   {IF_VAR rangedunit.length greater_than 0 (
#   [then]

    [foreach]
        array=rangedunit
        index_var=i
        [do]
            {SPARTAN_GET_RANGED_ATTACK_INDEX this_item}
            {VARIABLE tmp_targettype $this_item.attack[$tmp_spartan_ranged_index|].specials.spartan_ranged.targeting_type}#this will be checked when picking enemies
            {CLEAR_VARIABLE tmp_spartan_ranged_index}

        [if]
            [have_unit]
                id=$this_item.id
                [not]
                    formula="self.wml_vars.ranged_cooldown > 0"
                [/not]
            [/have_unit]
            [then]
                {STORE_TARGETHEXES_OF_ID $this_item.id tmp_current_targethexes}

#                {IF_VAR tmp_targettype equals assassin (
#                [then]
#                [store_unit]
#                    [filter]
#                        ability=hoplite_boss
#                        [filter_side]
#                            [enemy_of]
#                                side=$this_item.side
#                            [/enemy_of]
#                        [/filter_side]
#                        [filter_location]
#                             find_in=hoplite_targethexes#TODO: make a dedicated macro that goes through each targethex and checks it by id
#                        [/filter_location]
#                        [not]
#                            ability_type_active=hides
#                        [/not]
#                        [or]
#                        side=$hoplite_playerside
#                        [filter_side]
#                            [enemy_of]
#                                side=$this_item.side
#                            [/enemy_of]
#                        [/filter_side]
#                        [filter_location]
#                             find_in=hoplite_targethexes#TODO: make a dedicated macro that goes through each targethex and checks it by id
#                        [/filter_location]
#                        [not]
#                            ability_type_active=hides
#                        [/not]
#                        [/or]
#                        side=$hoplite_playerside,$hoplite_allyside
#                        [filter_location]
#                             find_in=hoplite_targethexes#TODO: make a dedicated macro that goes through each targethex and checks it by id
#                        [/filter_location]
#                        [not]
#                            ability_type_active=hides
#                        [/not]
#                    [/filter]
#                    variable=rangedunit_target_tmp
#                [/store_unit]
#
#                [store_unit]
#                    [filter]
#                        id=$rangedunit_target_tmp[0].id
#                    [/filter]
#                    variable=rangedunit_target
#                [/store_unit]
#                {CLEAR_VARIABLE rangedunit_target_tmp}
#                #if not important target found, works like first instead
#                {IF_VAR rangedtarget_loc.length greater_than 0 (
#                [else]
#                [foreach]
#                    array=hoplite_targethexes
#                    variable=this_targethex
#                    index_var=e
#                    [do]
#                        [chat]
#                            message=$this_targethex.x,$this_targethex.y
#                        [/chat]
#                        [if]
#                        [have_unit]
#                            x,y=$this_targethex.x,$this_targethex.y
#                        [filter_side]
#                            [enemy_of]
#                                side=$this_item.side
#                            [/enemy_of]
#                        [/filter_side]
#                        [not]
#                            ability_type_active=hides
#                        [/not]
#                        [/have_unit]
#                        [and]
#                            {VARIABLE_CONDITIONAL tmp_rangedtarget_found not_equals yes}
#                        [/and]
#                        [then]
#                            {VARIABLE tmp_rangedtarget_found yes}
#                            [store_unit]
#                                [filter]
#                                    x,y=$this_targethex.x,$this_targethex.y
#                                [/filter]
#                                variable=rangedunit_target
#                            [/store_unit]
#                        [/then]
#                        [/if]
#                    [/do]
#                [/foreach]
#                {CLEAR_VARIABLE tmp_rangedtarget_found}
#                [/else]
#                )}
#
#                [/then]
#                )}

#stores every target
                {IF_VAR tmp_targettype equals aoe (
                [then]
                [store_unit]
                    [filter]
                        [filter_side]
                            [enemy_of]
                                side=$this_item.side
                            [/enemy_of]
                        [/filter_side]
                        [filter_location]
                             find_in=tmp_current_targethexes
                        [/filter_location]
                        [not]
                            ability_type_active=hides
                        [/not]
                    [/filter]
                    variable=rangedunit_target
                [/store_unit]
                [/then]
                )}

#stores first enemy in a direction
                {IF_VAR tmp_targettype equals first (
                [then]
                [foreach]
                    array=tmp_current_targethexes
                    variable=this_targethex
                    index_var=e
                    [do]
#                        [chat]
#                            message=$this_targethex.x,$this_targethex.y
#                        [/chat]
                        [if]
                        [have_unit]
                            x,y=$this_targethex.x,$this_targethex.y
                        [filter_side]
                            [enemy_of]
                                side=$this_item.side
                            [/enemy_of]
                        [/filter_side]
                        [not]
                            ability_type_active=hides
                        [/not]
                        [/have_unit]
                        [and]
                            {VARIABLE_CONDITIONAL tmp_rangedtarget_found not_equals yes}
                        [/and]
                        [then]
                            {VARIABLE tmp_rangedtarget_found yes}
                            [store_unit]
                                [filter]
                                    x,y=$this_targethex.x,$this_targethex.y
                                [/filter]
                                variable=rangedunit_target
                            [/store_unit]
                        [/then]
                        [/if]
                    [/do]
                [/foreach]
                {CLEAR_VARIABLE tmp_rangedtarget_found}
                [/then]
                )}

                {VARIABLE tmp_ranged_animate yes}

                {HOPLITE_CLEAR_TARGETHEXES_BY_ID $this_item.id}
                {SPARTAN_GET_RANGED_ATTACK_INDEX this_item}
                [if]
                {VARIABLE_CONDITIONAL rangedunit_target.length greater_than 0}
                    [then]
                    [foreach]
                        array=rangedunit_target
                        variable=this_targetunit
                        index_var=r
                        [do]
                        {VARIABLE tmp_targetloc.x $this_targetunit.x}
                        {VARIABLE tmp_targetloc.y $this_targetunit.y}
                        [fire_event]
                            name=attack#to trigger teleportaway event
                            [primary_unit]
                                id=$this_item.id
                            [/primary_unit]
                            [secondary_unit]
                                id=$this_targetunit.id
                            [/secondary_unit]
                            [primary_attack]
                                name=$this_item.attack[$tmp_spartan_ranged_index].name
                                damage=$this_item.attack[$tmp_spartan_ranged_index].damage
                                type=$this_item.attack[$tmp_spartan_ranged_index].type
                            [/primary_attack]
                        [/fire_event]
                        [if]
                        [have_unit]
                            id=$this_targetunit.id
                            x,y=$tmp_targetloc.x,$tmp_targetloc.y#only attack the target if the target hasn't teleported before being attacked
                            [not]
                                ability_type_active=hides
                            [/not]
                        [/have_unit]
                        [then]
#does not work in side turn, moved to lower event:
#                            {MODIFY_UNIT id=$this_item.id moves 0}
#                            {MODIFY_UNIT id=$this_item.id attacks_left "$($this_item.attacks_left - 1)"}
                            [object]
                                silent=yes
                                duration=turn end
                                [filter]
                                    id=$this_item.id
                                [/filter]
                                [effect]
                                    apply_to=new_ability
                                    [abilities]
                                        [dummy]
                                            id=spartan_rangedattacked_this_turn
                                        [/dummy]
                                    [/abilities]
                                [/effect]
                            [/object]

                            [spartan_harm_unit]
                                [filter]
                                    id=$this_targetunit.id
                                [/filter]
                                [filter_second]
                                    id=$this_item.id
                                [/filter_second]
                                [primary_attack]
                                    name=$this_item.attack[$tmp_spartan_ranged_index].name
                                [/primary_attack]
                                amount=$this_item.attack[$tmp_spartan_ranged_index].damage
                                damage_type=$this_item.attack[$tmp_spartan_ranged_index].type
                                alignment=$this_item.alignment
                                fire_event=yes
                                animate=$tmp_ranged_animate
                                delay=0
                                experience=no
                            [/spartan_harm_unit]
                            [fire_event]
                                id=spartan_ranged_onhit_effects_$this_item.attack[$tmp_spartan_ranged_index].specials.spartan_ranged.rangedattack_id|
                            [/fire_event]
                            {VARIABLE tmp_ranged_animate defender}#this way, aoe attacks only trigger attack anims once per attack
                            [fire_event]
                                id=hoplite_adrenaline
                            [/fire_event]
                        [/then]
                        [/if]
                        {CLEAR_VARIABLE tmp_targetloc}
                        [/do]
                    [/foreach]
                    {CLEAR_VARIABLE tmp_ranged_animate}
                    {CLEAR_VARIABLE tmp_spartan_ranged_index}
                    [/then]
                    [else]
                        [fire_event]
                            id=spartan_ranged_onmiss_effects_$this_item.attack[$tmp_spartan_ranged_index].specials.spartan_ranged.rangedattack_id|
                        [/fire_event]
                    [/else]
                [/if]

#                {MODIFY_UNIT id=$this_item.id max_moves 1}
#                {MODIFY_UNIT id=$this_item.id moves 1}
#                {MODIFY_UNIT id=$this_item.id moves 0}
#                {MODIFY_UNIT id=$this_item.id attacks_left 0}

                {CLEAR_VARIABLE rangedunit_target}
                {CLEAR_VARIABLE tmp_current_targethexes}
            [/then]
        [/if]
        [/do]
    [/foreach]
    [/then]
    [/if]
#   [/then]
#   )}
    {CLEAR_VARIABLE rangedtarget_loc}
    {CLEAR_VARIABLE rangedunit}
[/event]
[event]
    id=spartan_apply_attack_and_move_reduction
    name=turn refresh
    first_time_only=no
    [filter_condition]
        [have_unit]
            ability=spartan_rangedattacked_this_turn
            side=$side_number
        [/have_unit]
    [/filter_condition]
    {CHATMSG "apply ranged attack attacks_left reduction"}

    [store_unit]
        [filter]
            ability=spartan_rangedattacked_this_turn
            side=$side_number
        [/filter]
        variable=spartan_rangedattacked_this_turn
        kill=no
    [/store_unit]
    [foreach]
        array=spartan_rangedattacked_this_turn
        index_var=i
        [do]
#decided to not remove moves for now, to make retreating ranged units a bit more dangerous. attacks are still subtracted though, to prevent semiranged units attacking with their melee right after a ranged attack, which is not ideal
#            {MODIFY_UNIT id=$this_item.id moves 0}
            {MODIFY_UNIT id=$this_item.id attacks_left "$($this_item.attacks_left - 1)"}
        [/do]
    [/foreach]
    {CLEAR_VARIABLE spartan_rangedattacked_this_turn}
[/event]
#this fix failed for some reason, might try again later and investigate in more detail
#[event]
#    name=attack end
#    id=spartan_targethex_knockback_fix
#    first_time_only=no
#    {HOPLITE_UPDATE_TARGETHEXES_BY_ID $second_unit.id}   
#[/event]
#enddef


#--- SCRAPPED CODE (tried to rework the microais to use variables, but sadly this_unit variable does not work in filter_location)

##define ABILITY_SPARTAN_RANGED RADIUS
##dummy ability used for indentifying ranged units, instead of having unit types pasted everywhere
#    [dummy]
#        id=hoplite_ranged
#    [/dummy]
#    [dummy]
#        id=hoplite_ranged_ai#for checking how close a ranged unit should be to players to attack
#    [/dummy]
#    [spartan_ranged_ai]
#        id=hoplite_ranged_ai2#for radius
#        radius={RADIUS}
#    [/spartan_ranged_ai]
##enddef
#
##define SPARTAN_RANGED_MICROAIS
#    [micro_ai]
#        side=$hoplite_enemyside
#        ai_type=goto
#        action=add
#        id=enemyranged_aim_at_player
#        [filter]
#            ability=hoplite_ranged_ai
#        [/filter]
#        [filter_location]
#            find_in=spartan_enemyranged_ai_locs
#            [and]
#                [filter]
#                    side=$hoplite_playerside,$hoplite_allyside
#                [/filter]
#                #using $| so that the variable isn't instantly substituted
#                radius=$|this_unit.abilities.spartan_ranged_ai.radius
#            [/and]
#            #doesn't waste turns trying to move to occupied locs
#            [not]
#                [filter]
#                    [not]
#                        ability=hoplite_ranged_ai#exception to make AI not move forward
#                    [/not]
#                [/filter]
#            [/not]
#        [/filter_location]
#        ca_score=140000#high but lower than coward ai
#        unique_goals=yes
#        remove_movement=no
#    [/micro_ai]
#    [micro_ai]
#        side=$hoplite_enemyside
#        ai_type=goto
#        action=add
#        id=enemyranged_aim_at_player_semiranged
#        [filter]
#            ability=hoplite_semiranged_ai
#            [not]
#                [filter_location]
#                [filter]
#                    side=$hoplite_playerside,$hoplite_allyside
#                [/filter]
#                radius=2
#                [/filter_location]
#            [/not]
#        [/filter]
#        [filter_location]
#            find_in=spartan_enemyranged_ai_locs
#            [and]
#                [filter]
#                    side=$hoplite_playerside,$hoplite_allyside
#                [/filter]
#                #using $| so that the variable isn't instantly substituted
#                radius=$|this_unit.abilities.spartan_ranged_ai.radius
#            [/and]
#            #doesn't waste turns trying to move to occupied locs
#            [not]
#                [filter]
#                    [not]
#                        ability=hoplite_semiranged_ai#exception to make AI not move forward
#                    [/not]
#                [/filter]
#            [/not]
#        [/filter_location]
#        ca_score=140000#high but lower than coward ai
#        unique_goals=yes
#        remove_movement=no
#    [/micro_ai]
#    [micro_ai]
#        side=$hoplite_allyside
#        ai_type=goto
#        action=add
#        id=allyranged_aim_at_enemies
#        [filter]
#            ability=hoplite_ranged_ai
#        [/filter]
#        [filter_location]
#            find_in=spartan_allyranged_ai_locs
#            [and]
#                [filter]
#                    side=$hoplite_enemyside
#                [/filter]
#                #using $| so that the variable isn't instantly substituted
#                radius=$|this_unit.abilities.spartan_ranged_ai.radius
#            [/and]
#            #doesn't waste turns trying to move to occupied locs
#            [not]
#                [filter]
#                    [not]
#                        ability=hoplite_ranged_ai#exception to make AI not move forward
#                    [/not]
#                [/filter]
#            [/not]
#        [/filter_location]
#        ca_score=140000#high but lower than coward ai
#        unique_goals=yes
#        remove_movement=no
#    [/micro_ai]
#    [micro_ai]
#        side=$hoplite_allyside
#        ai_type=goto
#        action=add
#        id=allyranged_aim_at_enemies_semiranged
#        [filter]
#            ability=hoplite_semiranged_ai
#            [not]
#                [filter_location]
#                [filter]
#                    side=$hoplite_enemyside
#                [/filter]
#                radius=2
#                [/filter_location]
#            [/not]
#        [/filter]
#        [filter_location]
#            find_in=spartan_allyranged_ai_locs
#            [and]
#                [filter]
#                    side=$hoplite_enemyside
#                [/filter]
#                #using $| so that the variable isn't instantly substituted
#                radius=$|this_unit.abilities.spartan_ranged_ai.radius
#            [/and]
#            #doesn't waste turns trying to move to occupied locs
#            [not]
#                [filter]
#                    [not]
#                        ability=hoplite_semiranged_ai#exception to make AI not move forward
#                    [/not]
#                [/filter]
#            [/not]
#        [/filter_location]
#        ca_score=140000#high but lower than coward ai
#        unique_goals=yes
#        remove_movement=no
#    [/micro_ai]
##enddef
#
###define ABILITY_SEMIRANGED
###for units like cuttlefish, for whom the coward ai is not needed
##    [dummy]
##        id=hoplite_semiranged
##    [/dummy]
###enddef
#
##define ABILITY_SPARTAN_SEMIRANGED RADIUS
##for units like cuttlefish, for whom the coward ai is not needed
#    [dummy]
#        id=hoplite_semiranged
#    [/dummy]
#    [spartan_rangedai]
#        id=hoplite_semiranged_ai#for checking how close a ranged unit should be to players to attack
#        radius={RADIUS}
#    [/spartan_rangedai]
##enddef