#textdomain wesnoth-Hoplite

#define TARGETUNITS_FILTER_PART_NEW VAR DIR
    [or]
        #todo: add an enemy side filter with [filter_side]
        side=$hoplite_playerside,$hoplite_allyside
        [filter_location]
            find_in=$ranged_targetlocs{DIR}#TODO: make it checked by id too
        [/filter_location]
    [/or]
#enddef

#define STORE_TARGETLOCS_PART_NEW VAR DIR DISTANCE BLINDSPOT
    {VARIABLE previousloc.x ${VAR}.x}
    {VARIABLE previousloc.y ${VAR}.y}
    {VARIABLE blindspot_index -1}
    {REPEAT {BLINDSPOT} (
        [store_locations]
            terrain=!,Xu*,Xo*
            [filter_adjacent_location]
                x,y=$previousloc.x,$previousloc.y
                adjacent={DIR}
            [/filter_adjacent_location]
            variable=ranged_blindspots{DIR}
            include_borders=no
            mode=append
        [/store_locations]
        {VARIABLE_OP blindspot_index add 1}
        {IF_VAR ranged_blindspots{DIR}[$blindspot_index].x greater_than 0 (
        [then]
            {VARIABLE previousloc.x $ranged_blindspots{DIR}[$blindspot_index].x}
            {VARIABLE previousloc.y $ranged_blindspots{DIR}[$blindspot_index].y}
        [/then]
        )}
    )}

    {VARIABLE ranged_truerange {DISTANCE}}
    {VARIABLE_OP ranged_truerange sub {BLINDSPOT}}
    {VARIABLE targetloc_index -1}

    {REPEAT $ranged_truerange (
        [store_locations]
            terrain=!,Xu*,Xo*
            [filter_adjacent_location]
                x,y=$previousloc.x,$previousloc.y
                adjacent={DIR}
            [/filter_adjacent_location]
            variable=ranged_targetlocs{DIR}
            include_borders=no
            mode=append
        [/store_locations]
        {VARIABLE_OP targetloc_index add 1}
        {IF_VAR ranged_targetlocs{DIR}[$targetloc_index].x greater_than 0 (
        [then]
            {VARIABLE previousloc.x $ranged_targetlocs{DIR}[$targetloc_index].x}
            {VARIABLE previousloc.y $ranged_targetlocs{DIR}[$targetloc_index].y}
        [/then]
        )}
    )}
#enddef

#define CLEAR_DIRECTIONAL_VARS VAR
{CLEAR_VARIABLE {VAR}n}
{CLEAR_VARIABLE {VAR}ne}
{CLEAR_VARIABLE {VAR}nw}
{CLEAR_VARIABLE {VAR}s}
{CLEAR_VARIABLE {VAR}se}
{CLEAR_VARIABLE {VAR}sw}
#enddef

#define HOPLITE_CLEAR_TMP_TARGETHEXES
    {CLEAR_DIRECTIONAL_VARS ranged_blindspots}
    {CLEAR_DIRECTIONAL_VARS ranged_targetlocs}
#enddef

#define HOPLITE_REMOVE_CURRENT_TARGEHEX
    [set_variables]
        name=tmp_remove_item_tag_container
        [value]
            x=$hoplite_targethexes[$c].x
            y=$hoplite_targethexes[$c].y
            image=$hoplite_targethexes[$c].name
        [/value]
    [/set_variables]

    #am using [insert_tag] instead of just remove_item, otherwise the game doesn't substitute the id variable for some reason

    [insert_tag]
        name=remove_item
        variable=tmp_remove_item_tag_container
    [/insert_tag]

    {CLEAR_VARIABLE tmp_remove_item_tag_container}
#enddef

#define HOPLITE_CLEAR_TARGETHEXES_BY_ID ID
#using a while loop (original deprecated FOREACH implementation) instead of foreach as it's better for deleting array elements
{VARIABLE c 0}
[while]
    [variable]
    name=c
    less_than=$hoplite_targethexes.length
    [/variable]
    [do]
        {IF_VAR hoplite_targethexes[$c].unit_id equals {ID} (
            [then]
                [chat]
                    message=$hoplite_targethex$hoplite_targethexes[$c].unit_id
                [/chat]
                {HOPLITE_REMOVE_CURRENT_TARGEHEX}
                {CLEAR_VARIABLE hoplite_targethexes[$c]}
                {VARIABLE_OP c sub 1}#this is to fix weirdness when something in an array is deleted
            [/then]
        )}
    [set_variable]
    name=c
    add=1
    [/set_variable]
    [/do]
[/while]
{CLEAR_VARIABLE c}
#enddef

#TODO: use this in level generation code for going into next depth

#define HOPLITE_CLEAR_ALL_TARGETHEXES
#using a while loop (original deprecated FOREACH implementation) instead of foreach as it's better for deleting array elements
{VARIABLE c 0}
[while]
    [variable]
    name=c
    less_than=$hoplite_targethexes.length
    [/variable]
    [do]
        {HOPLITE_REMOVE_CURRENT_TARGEHEX}
        {CLEAR_VARIABLE hoplite_targethexes[$c]}
#        {VARIABLE_OP c sub 1}#this is to fix weirdness when something in an array is deleted
#    [set_variable]
#    name=c
#    add=1
#    [/set_variable]
    [/do]
[/while]
{CLEAR_VARIABLE c}
#enddef

#define HOPLITE_CLEAR_TARGETHEXES_IF_UNIT_NOT_FOUND
#using a while loop (original deprecated FOREACH implementation) instead of foreach as it's better for deleting array elements
{VARIABLE c 0}
[while]
    [variable]
    name=c
    less_than=$hoplite_targethexes.length
    [/variable]
    [do]
        [if]
        [have_unit]
            id=$hoplite_targethexes[$c].unit_id
            #slowed units can't use ranged attacks anyway, so clear the targethexes
            [not]
                [filter_wml]
                    [status]
                        slowed=yes
                    [/status]
                [/filter_wml]
            [/not]
        [/have_unit]
        [else]
            {HOPLITE_REMOVE_CURRENT_TARGEHEX}            
            {CLEAR_VARIABLE hoplite_targethexes[$c]}
            {VARIABLE_OP c sub 1}#this is to fix weirdness when something in an array is deleted
        [/else]
        [/if]
    [set_variable]
    name=c
    add=1
    [/set_variable]
    [/do]
[/while]
{CLEAR_VARIABLE c}
#enddef

#define HOPLITE_IFHAVELOC_NEW LOC1 DIR DISTANCE BLINDSPOT STORELOC
    [store_locations]
        [filter_adjacent_location]
            x,y={LOC1}
            adjacent={DIR}
        [/filter_adjacent_location]
        variable=targethex_test
        include_borders=no
    [/store_locations]
    [if]
        [have_location]
            x=$targethex_test.x
            y=$targethex_test.y
        [not]
            terrain=Xu*,Xo*
        [/not]
        [filter_adjacent_location]
                x,y={LOC1}
        [/filter_adjacent_location]
#            [and]
#                x,y={LOC1}
#                radius=1
#            [/and]
        [/have_location]
    [and]
        [have_location]
            x=$targethex_test.x
            y=$targethex_test.y
        [/have_location]
    [/and]
    [and]
        [have_location]
            x,y={LOC1}
        terrain=!,Xu*,Xo*
        [/have_location]
    [/and]
        [then]
            {STORELOC}
        [/then]
        [else]
        [/else]
    [/if]
    {CLEAR_VARIABLE targethex_test}
#enddef

#define STORE_TARGETHEX_LOC_NEW VAR DISTANCE BLINDSPOT
    {STORE_TARGETLOCS_PART_NEW {VAR} n {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART_NEW {VAR} ne {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART_NEW {VAR} nw {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART_NEW {VAR} s {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART_NEW {VAR} se {DISTANCE} {BLINDSPOT}}
    {STORE_TARGETLOCS_PART_NEW {VAR} sw {DISTANCE} {BLINDSPOT}}
#enddef

#define TARGETUNITS_FILTER_NEW VAR
    {TARGETUNITS_FILTER_PART_NEW {VAR} n}
    {TARGETUNITS_FILTER_PART_NEW {VAR} ne}
    {TARGETUNITS_FILTER_PART_NEW {VAR} nw}
    {TARGETUNITS_FILTER_PART_NEW {VAR} s}
    {TARGETUNITS_FILTER_PART_NEW {VAR} se}
    {TARGETUNITS_FILTER_PART_NEW {VAR} sw}
#enddef

#define WEAPON_SPECIAL_HOPLITE_RANGED ID ATTACK_INDEX RANGE BLINDSPOT TARGETHEX_IMG TARGETING_TYPE ONHIT_EFFECTS
#TODO: rangedtype values:
 #first: targets the first enemy in a direction
 #aoe: targets every enemy in a direction
 #first_blockeally: like first, but doesn't pick the direction if there is an ally in the way
 #aoe_blockally: like aoe, but doesn't pick the direction if there is an ally in the way
 #random: randomly picks an enemy in the chosen direction
 #SCRAPPED: assassin: always aims for player characters or bosses, even if there is a weaker enemy in the way, can shoot through own allies
    [dummy]
        id=hoplite_ranged{ID}
        name= _ "ranged attack"
        description=_"Unlike normal wesnoth, ranged attacks can attack over a distance of multiple tiles. At the start of the player turn, all ranged units will aim at enemies, and the hexes they can shoot at will be highlighted (yellow for single-target attacks, red for AOE attacks, blue for slowing attacks)"
    [/dummy] # wmlxgettext: [abilities]
[/specials]
[/attack]
#not necessary, since ranged events are done by id anyway
#[event]
#    name=unit placed,post advance
#    id=rangedcombat{ID}_set_index_var
#    first_time_only=no
#    [filter]
#        [has_attack]
#            special_id=hoplite_ranged{ID}
#        [/has_attack]
#    [/filter]
#    [modify_unit]
#        [filter]
#            id=$unit.id
#        [/filter]
#        [set_variable]
#            name=rangedattack_index
#            value={ATTACK_INDEX}
#        [/set_variable]
#    [/modify_unit]    
#[/event]
[event]
    name=new turn
    id=rangedcombat{ID}_aim
    first_time_only=no

    {CHATMSG "reworked ranged aim"}

    [store_unit]
        [filter]
            [has_attack]
                special_id=hoplite_ranged{ID}
            [/has_attack]
            [not]
                [filter_wml]
                    [status]
                        slowed=yes
                    [/status]
                [/filter_wml]
                [or]
                    ability=hoplite_ranged_cooldown
                [/or]
            [/not]
        [/filter]
        variable=rangedunit_aiming_{ID}
        kill=no
    [/store_unit]

    {VARIABLE tmp_targettype {TARGETING_TYPE}}#this will be checked when picking enemies

    [foreach]
        array=rangedunit_aiming_{ID}
        index_var=a
        [do]

        [if]
            [have_unit]
                id=$this_item.id
                [not]
                    formula="self.wml_vars.ranged_cooldown > 0"
                [/not]
            [/have_unit]
            [else]
            [modify_unit]
                [filter]
                    id=$this_item.id
                [/filter]
                [set_variable]
                    name=ranged_cooldown
                    sub=1
                [/set_variable]
            [/modify_unit]
            [/else]
            [then]

    {STORE_TARGETHEX_LOC_NEW this_item {RANGE} {BLINDSPOT}}
#scrapped for now
#{IF_VAR tmp_targettype equals assassin (
#[then]
#    [store_unit]
#        [filter]
#            ability=hoplite_boss
#            [filter_side]
#                [enemy_of]
#                    side=$this_item.side
#                [/enemy_of]
#            [/filter_side]
#            {TARGETUNITS_FILTER_NEW this_item}
#            [not]
#                ability_type_active=hides
#            [/not]
#            [or]
#            side=$hoplite_playerside
#            [filter_side]
#                [enemy_of]
#                    side=$this_item.side
#                [/enemy_of]
#            [/filter_side]
#            {TARGETUNITS_FILTER_NEW this_item}
#            [not]
#                ability_type_active=hides
#            [/not]
#            [/or]
#        [/filter]
#        variable=hoplite_loc
#        kill=no
#    [/store_unit]
#[/then]
#)}

{IF_VAR hoplite_loc.length greater_than 0 (
[else]
    [store_unit]
        [filter]
            [filter_side]
                [enemy_of]
                    side=$this_item.side
                [/enemy_of]
            [/filter_side]
            {TARGETUNITS_FILTER_NEW this_item}
            [not]
                ability_type_active=hides
            [/not]
        [/filter]
        variable=hoplite_loc
        kill=no
    [/store_unit]
[/else]
)}
    {RANDOM 0.."$($hoplite_loc.length| - 1)"}
    {VARIABLE rangedunit_{ID}_hopliteloc_x $hoplite_loc[$random].x}
    {VARIABLE rangedunit_{ID}_hopliteloc_y $hoplite_loc[$random].y}
#    [animate_unit]
#        flag=standing
#        [facing]
#            [filter]
#                x=$rangedunit_{ID}_hopliteloc_x
#                y=$rangedunit_{ID}_hopliteloc_y
#            [/filter]
#        [/facing]
#        [filter]
#            x=$this_item.x
#            y=$this_item.y
#        [/filter]
#    [/animate_unit]

    [if]
    {VARIABLE_CONDITIONAL hoplite_loc.length greater_than 0}
    [then]

    [lua]
        code=<<

        local args = ...

        --direction is intentionally reversed for aiming
        --                        local dir = wesnoth.map.get_relative_dir({x = args.x1, y = args.y1},{x = args.x2, y = args.y2})
        local dir = wesnoth.map.get_relative_dir({x = args.x2, y = args.y2},{x = args.x1, y = args.y1})
        wesnoth.set_variable("tmp_ranged_dir", dir)

        >>
        [args]
            x1=$this_item.x
            y1=$this_item.y
            x2=$rangedunit_{ID}_hopliteloc_x
            y2=$rangedunit_{ID}_hopliteloc_y
        [/args]
    [/lua]

    [/then]
    [/if]


    [if]
        [have_unit]
            [filter_side]
                [enemy_of]
                    side=$this_item.side
                [/enemy_of]
            [/filter_side]
            [filter_location]
                find_in=ranged_targetlocs$tmp_ranged_dir
            [/filter_location]
            [not]
                ability_type_active=hides
            [/not]
        [/have_unit]
        [then]

            [foreach]
                array=ranged_targetlocs$tmp_ranged_dir
                variable=this_item2
                index_var=e
                [do]

                [set_variables]
                    name=tmp_item_tag_container
                    [value]
                        x=$this_item2.x
                        y=$this_item2.y
                        image={TARGETHEX_IMG}
                        name=hoplite_targethex$this_item.id
                    [/value]
                [/set_variables]

                #am using [insert_tag] instead of just item, otherwise the game doesn't substitute the id variable for some reason

                [insert_tag]
                    name=item
                    variable=tmp_item_tag_container
                [/insert_tag]

                {CLEAR_VARIABLE tmp_item_tag_container}

#                [item]
#                    x,y=$this_item2.x,$this_item2.y
#                    image="misc/targethex-archer.png"
#                    name=hoplite_targethex$|this_item.id
#                [/item]

#                [store_locations]
#                    x,y=$this_item2.x,$this_item2.y
#                    variable=$this_item.id|targethexes
#                    mode=append
#                [/store_locations]

                [set_variables]
                    name=hoplite_targethexes
                    mode=append
                    [value]
                        unit_id=$this_item.id
                        x=$this_item2.x
                        y=$this_item2.y
                        name=hoplite_targethex$this_item.id
                    [/value]
                [/set_variables]

                [/do]
            [/foreach]

            [store_items]
                x=0-99
                y=0-99
                variable=stored_items
            [/store_items]

            [sound]
                name=magic-dark-big-miss.ogg
            [/sound]
            [object]
                silent=yes
                duration=turn
                [filter]
                    find_in=this_item
                [/filter]
                [effect]
                    apply_to=new_ability
                    [abilities]
                        [dummy]
                            id=hoplite_charging
                        [/dummy]
                    [/abilities]
                [/effect]
            [/object]
            {MODIFY_UNIT id=$this_item.id moves 0}
            {MODIFY_UNIT id=$this_item.id max_moves 0}
        [/then]
    [/if]

    [delay]
        time=500
    [/delay]

#    {HOPLITE_CLEAR_TARGETHEXES_BY_ID $this_item.id}

    {HOPLITE_CLEAR_TMP_TARGETHEXES}

    [/then]
    [/if]

        [/do]
    [/foreach]


#   {IF_VAR rangedunit_{ID}.length greater_than 0 (
#   [then]
#    {FOREACH rangedunit_{ID} a}

#    {NEXT a}
    {CLEAR_VARIABLE rangedunit_aiming_{ID}}
[/event]
[event]
    name=side turn,die,attack end
    id=hoplite_clear_targethexes
    first_time_only=no
    {HOPLITE_CLEAR_TARGETHEXES_IF_UNIT_NOT_FOUND}
[/event]
[event]
    name=side turn
    id=rangedcombat{ID}
    {CHATMSG "reworked ranged combat"}
    first_time_only=no
    [if]
    [have_unit]
        [has_attack]
            special_id=hoplite_ranged{ID}
        [/has_attack]
    [/have_unit]
    [then]
    [store_unit]
        [filter]
            [has_attack]
                special_id=hoplite_ranged{ID}
            [/has_attack]
            [and]
                ability=hoplite_charging
            [/and]
            side=$side_number
            [not]
                [filter_wml]
                    [status]
                        slowed=yes
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        variable=rangedunit_{ID}
        kill=no
    [/store_unit]
#   {IF_VAR rangedunit_{ID}.length greater_than 0 (
#   [then]

    {VARIABLE tmp_targettype {TARGETING_TYPE}}#this will be checked when picking enemies

    [foreach]
        array=rangedunit_{ID}
        index_var=i
        [do]
        [if]
            [have_unit]
                id=$this_item.id
                [not]
                    formula="self.wml_vars.ranged_cooldown > 0"
                [/not]
            [/have_unit]
            [then]

#                {IF_VAR tmp_targettype equals assassin (
#                [then]
#                [store_unit]
#                    [filter]
#                        ability=hoplite_boss
#                        [filter_side]
#                            [enemy_of]
#                                side=$this_item.side
#                            [/enemy_of]
#                        [/filter_side]
#                        [filter_location]
#                             find_in=hoplite_targethexes#TODO: make a dedicated macro that goes through each targethex and checks it by id
#                        [/filter_location]
#                        [not]
#                            ability_type_active=hides
#                        [/not]
#                        [or]
#                        side=$hoplite_playerside
#                        [filter_side]
#                            [enemy_of]
#                                side=$this_item.side
#                            [/enemy_of]
#                        [/filter_side]
#                        [filter_location]
#                             find_in=hoplite_targethexes#TODO: make a dedicated macro that goes through each targethex and checks it by id
#                        [/filter_location]
#                        [not]
#                            ability_type_active=hides
#                        [/not]
#                        [/or]
#                        side=$hoplite_playerside,$hoplite_allyside
#                        [filter_location]
#                             find_in=hoplite_targethexes#TODO: make a dedicated macro that goes through each targethex and checks it by id
#                        [/filter_location]
#                        [not]
#                            ability_type_active=hides
#                        [/not]
#                    [/filter]
#                    variable=rangedunit_{ID}_target_tmp
#                [/store_unit]
#
#                [store_unit]
#                    [filter]
#                        id=$rangedunit_{ID}_target_tmp[0].id
#                    [/filter]
#                    variable=rangedunit_{ID}_target
#                [/store_unit]
#                {CLEAR_VARIABLE rangedunit_{ID}_target_tmp}
#                #if not important target found, works like first instead
#                {IF_VAR hoplite_loc.length greater_than 0 (
#                [else]
#                [foreach]
#                    array=hoplite_targethexes
#                    variable=this_targethex
#                    index_var=e
#                    [do]
#                        [chat]
#                            message=$this_targethex.x,$this_targethex.y
#                        [/chat]
#                        [if]
#                        [have_unit]
#                            x,y=$this_targethex.x,$this_targethex.y
#                        [filter_side]
#                            [enemy_of]
#                                side=$this_item.side
#                            [/enemy_of]
#                        [/filter_side]
#                        [not]
#                            ability_type_active=hides
#                        [/not]
#                        [/have_unit]
#                        [and]
#                            {VARIABLE_CONDITIONAL tmp_rangedtarget_found not_equals yes}
#                        [/and]
#                        [then]
#                            {VARIABLE tmp_rangedtarget_found yes}
#                            [store_unit]
#                                [filter]
#                                    x,y=$this_targethex.x,$this_targethex.y
#                                [/filter]
#                                variable=rangedunit_{ID}_target
#                            [/store_unit]
#                        [/then]
#                        [/if]
#                    [/do]
#                [/foreach]
#                {CLEAR_VARIABLE tmp_rangedtarget_found}
#                [/else]
#                )}
#
#                [/then]
#                )}

#stores every target
                {IF_VAR tmp_targettype equals aoe (
                [then]
                [store_unit]
                    [filter]
                        [filter_side]
                            [enemy_of]
                                side=$this_item.side
                            [/enemy_of]
                        [/filter_side]
                        [filter_location]
                             find_in=hoplite_targethexes#TODO: maybe make a dedicated macro that goes through each targethex and checks it by id
                        [/filter_location]
                        [not]
                            ability_type_active=hides
                        [/not]
                    [/filter]
                    variable=rangedunit_{ID}_target
                [/store_unit]
                [/then]
                )}

#stores first enemy in a direction
                {IF_VAR tmp_targettype equals first (
                [then]
                [foreach]
                    array=hoplite_targethexes
                    variable=this_targethex
                    index_var=e
                    [do]
                        [chat]
                            message=$this_targethex.x,$this_targethex.y
                        [/chat]
                        [if]
                        [have_unit]
                            x,y=$this_targethex.x,$this_targethex.y
                        [filter_side]
                            [enemy_of]
                                side=$this_item.side
                            [/enemy_of]
                        [/filter_side]
                        [not]
                            ability_type_active=hides
                        [/not]
                        [/have_unit]
                        [and]
                            {VARIABLE_CONDITIONAL tmp_rangedtarget_found not_equals yes}
                        [/and]
                        [then]
                            {VARIABLE tmp_rangedtarget_found yes}
                            [store_unit]
                                [filter]
                                    x,y=$this_targethex.x,$this_targethex.y
                                [/filter]
                                variable=rangedunit_{ID}_target
                            [/store_unit]
                        [/then]
                        [/if]
                    [/do]
                [/foreach]
                {CLEAR_VARIABLE tmp_rangedtarget_found}
                [/then]
                )}


                {VARIABLE tmp_ranged_animate yes}

                {HOPLITE_CLEAR_TARGETHEXES_BY_ID $this_item.id}
                [if]
                {VARIABLE_CONDITIONAL rangedunit_{ID}_target.length greater_than 0}
                    [then]

                    [foreach]
                        array=rangedunit_{ID}_target
                        variable=this_targetunit
                        index_var=r
                        [do]
                        {VARIABLE tmp_targetloc.x $this_targetunit.x}
                        {VARIABLE tmp_targetloc.y $this_targetunit.y}
                        [fire_event]
                            name=attack#to trigger teleportaway event
                            [primary_unit]
                                id=$this_item.id
                            [/primary_unit]
                            [secondary_unit]
                                id=$this_targetunit.id
                            [/secondary_unit]
                            [primary_attack]
                                name=$this_item.attack[{ATTACK_INDEX}].name
                                damage=$this_item.attack[{ATTACK_INDEX}].damage
                                type=$this_item.attack[{ATTACK_INDEX}].type
                            [/primary_attack]
                        [/fire_event]
                        [if]
                        [have_unit]
                            id=$this_targetunit.id
                            x,y=$tmp_targetloc.x,$tmp_targetloc.y#only attack the target if the target hasn't teleported before being attacked
                            [not]
                                ability_type_active=hides
                            [/not]
                        [/have_unit]
                        [then]
                            {MODIFY_UNIT id=$this_item.id moves 0}
                            {MODIFY_UNIT id=$this_item.id attacks_left 0}#TODO: make this sub attacks_left by 1 instead

                            [harm_unit]
                                [filter]
                                    id=$this_targetunit.id
                                [/filter]
                                [filter_second]
                                    id=$this_item.id
                                [/filter_second]
                                [primary_attack]
                                    name=$this_item.attack[{ATTACK_INDEX}].name
                                [/primary_attack]
                                amount=$this_item.attack[{ATTACK_INDEX}].damage
                                damage_type=$this_item.attack[{ATTACK_INDEX}].type
                                alignment=$this_item.alignment
                                fire_event=yes
                                animate=$tmp_ranged_animate
                                delay=0
                                experience=no
                            [/harm_unit]
                            {ONHIT_EFFECTS}
                            {VARIABLE tmp_ranged_animate defender}#this way, aoe attacks only trigger attack anims once per attack
                            [fire_event]
                                id=hoplite_adrenaline
                            [/fire_event]
                        [/then]
                        [/if]
                        {CLEAR_VARIABLE tmp_targetloc}
                        [/do]
                    [/foreach]
                    {CLEAR_VARIABLE tmp_ranged_animate}
                    [/then]
                [/if]

#                {MODIFY_UNIT id=$this_item.id max_moves 1}
#                {MODIFY_UNIT id=$this_item.id moves 1}
#                {MODIFY_UNIT id=$this_item.id moves 0}
#                {MODIFY_UNIT id=$this_item.id attacks_left 0}

                {CLEAR_VARIABLE rangedunit_{ID}_target}
                {CLEAR_VARIABLE targethex_rangedunit_{ID}1[$a]}
                {CLEAR_VARIABLE targethex_rangedunit_{ID}2[$a]}
                {CLEAR_VARIABLE targethex_rangedunit_{ID}3[$a]}
                {CLEAR_VARIABLE targethex_rangedunit_{ID}4[$a]}
            [/then]
        [/if]
        [/do]
    [/foreach]
    [/then]
    [/if]
#   [/then]
#   )}
    {CLEAR_VARIABLE hoplite_loc}
    {CLEAR_VARIABLE rangedunit_{ID}}
[/event]
[+attack]
[+specials]
#enddef